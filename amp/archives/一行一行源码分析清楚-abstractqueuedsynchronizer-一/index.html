<!DOCTYPE html>




<html amp lang="zh-cn" class="no-js">
<head>
  <title>一行一行源码分析清楚 AbstractQueuedSynchronizer (一)</title>
  <meta charset="utf-8">

  <script async custom-element="amp-ad" src="https://cdn.ampproject.org/v0/amp-ad-0.1.js"></script><script async custom-element="amp-analytics" src="https://cdn.ampproject.org/v0/amp-analytics-0.1.js"></script>

    <script async src="https://cdn.ampproject.org/v0.js"></script>

    




  <link rel="canonical" href="https://www.zhouyi.tech/archives/%E4%B8%80%E8%A1%8C%E4%B8%80%E8%A1%8C%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E6%B8%85%E6%A5%9A-abstractqueuedsynchronizer-%E4%B8%80/">

  <link rel="icon" href="https://www.zhouyi.tech/favicon.png" type="image/png" sizes="144x144">

  <meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1">

  <meta name="theme-color" content="#000000" />

  
<script type="application/ld+json">
{
    "@context": "http://schema.org",
    "@type": "WebSite",
    "name": "程序员学习之路",
    
    "url": "https:\/\/www.zhouyi.tech"
}
</script>
<script type="application/ld+json">
{
  "@context": "http://schema.org",
  "@type": "Organization",
  "name": "",
  "url": "https:\/\/www.zhouyi.tech"
  
  
  
  
}
</script>
































<script type="application/ld+json">
{
  "@context": "http://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [{
        "@type": "ListItem",
        "position":  1 ,
        "item": {
          "@id": "https:\/\/www.zhouyi.tech",
          "name": "home"
        }
    },{
        "@type": "ListItem",
        "position":  3 ,
        "item": {
          "@id": "https:\/\/www.zhouyi.tech\/amp\/",
          "name": "amp"
        }
    },{
        "@type": "ListItem",
        "position":  4 ,
        "item": {
          "@id": "https:\/\/www.zhouyi.tech\/amp\/archives\/",
          "name": "archives"
        }
    },{
        "@type": "ListItem",
        "position":  5 ,
        "item": {
          "@id": "https:\/\/www.zhouyi.tech\/amp\/archives\/%E4%B8%80%E8%A1%8C%E4%B8%80%E8%A1%8C%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E6%B8%85%E6%A5%9A-abstractqueuedsynchronizer-%E4%B8%80\/",
          "name": "%E4%B8%80%E8%A1%8C%E4%B8%80%E8%A1%8C%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E6%B8%85%E6%A5%9A-abstractqueuedsynchronizer-%E4%B8%80"
        }
    }]
}
</script>





    <style amp-boilerplate>body{-webkit-animation:-amp-start 8s steps(1,end) 0s 1 normal both;-moz-animation:-amp-start 8s steps(1,end) 0s 1 normal both;-ms-animation:-amp-start 8s steps(1,end) 0s 1 normal both;animation:-amp-start 8s steps(1,end) 0s 1 normal both}@-webkit-keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}@-moz-keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}@-ms-keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}@-o-keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}@keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}</style><noscript><style amp-boilerplate>body{-webkit-animation:none;-moz-animation:none;-ms-animation:none;animation:none}</style></noscript>
    <style amp-custom>
        /**
* stylesheet.html
* ---------------
* This is the stylesheet that gets injected as a fallback if no layouts/partials/stylesheet.html file is available
* in your project file.
*
* For further details, please have a look at:
* https://gohugo-amp.gohugohq.com/install/
*
**/
html{font-family:sans-serif;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}body{margin:0}article,aside,details,figcaption,figure,footer,header,hgroup,main,nav,section,summary{display:block}audio,canvas,progress,video{display:inline-block;vertical-align:baseline}audio:not([controls]){display:none;height:0}[hidden],template{display:none}a{background:transparent}a:active,a:hover{outline:0}abbr[title]{border-bottom:1px
dotted}b,strong{font-weight:700}dfn{font-style:italic}h1{font-size:2em;margin:.67em
0}mark{background:#ff0;color:#000}small{font-size:80%}sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}sup{top:-.5em}sub{bottom:-.25em}img{border:0}svg:not(:root){overflow:hidden}figure{margin:1em
40px}hr{box-sizing:content-box;height:0}pre{overflow:auto}code,kbd,pre,samp{font-family:monospace,monospace;font-size:1em}button,input,optgroup,select,textarea{color:inherit;font:inherit;margin:0}button{overflow:visible}button,select{text-transform:none}button,html
input[type=button],input[type=reset],input[type=submit]{-webkit-appearance:button;cursor:pointer}button[disabled],html
input[disabled]{cursor:default}button::-moz-focus-inner,input::-moz-focus-inner{border:0;padding:0}input{line-height:normal}input[type=checkbox],input[type=radio]{box-sizing:border-box;padding:0}input[type=number]::-webkit-inner-spin-button,input[type=number]::-webkit-outer-spin-button{height:auto}input[type=search]{-webkit-appearance:textfield;box-sizing:content-box}input[type=search]::-webkit-search-cancel-button,input[type=search]::-webkit-search-decoration{-webkit-appearance:none}fieldset{border:1px
solid silver;margin:0 2px;padding:.35em .625em
.75em}legend{border:0;padding:0}textarea{overflow:auto}optgroup{font-weight:700}td,th{padding:0}*{box-sizing:border-box}button,input,select,textarea{font:13px/1.4
Helvetica,arial,freesans,clean,sans-serif}a{color:#4183c4;text-decoration:none}a:active,a:focus,a:hover{text-decoration:underline}.rule,hr{height:0;margin:15px
0;overflow:hidden;background:transparent;border:0;border-bottom:1px solid
#ddd}.rule:after,.rule:before,hr:after,hr:before{display:table;content:""}.rule:after,hr:after{clear:both}fieldset{padding:0;margin:0;border:0}label{font-size:13px;font-weight:700}#adv_code_search
.search-page-label,input[type=email],input[type=number],input[type=password],input[type=tel],input[type=text],input[type=url],textarea{min-height:34px;padding:7px
8px;font-size:13px;color:#333;vertical-align:middle;background-color:#fff;background-repeat:no-repeat;background-position:100%;border:1px
solid #ccc;border-radius:3px;outline:none;box-shadow:inset 0 1px 2px rgba(0,0,0,.075)}#adv_code_search
.focus.search-page-label,#adv_code_search .search-page-label:focus,.focused
.drag-and-drop,input[type=email].focus,input[type=email]:focus,input[type=number].focus,input[type=number]:focus,input[type=password].focus,input[type=password]:focus,input[type=tel].focus,input[type=tel]:focus,input[type=text].focus,input[type=text]:focus,input[type=url].focus,input[type=url]:focus,textarea.focus,textarea:focus{border-color:#51a7e8;box-shadow:inset
0 1px 2px rgba(0,0,0,.075),0 0 5px
rgba(81,167,232,.5)}.input-contrast,input.input-contrast{background-color:#fafafa}.input-contrast:focus,input.input-contrast:focus{background-color:#fff}:-moz-placeholder,::-webkit-input-placeholder{color:#aaa}::-webkit-validation-bubble-message{font-size:12px;color:#fff;background:#9c2400;border:0;border-radius:3px;-webkit-box-shadow:1px
1px 1px
rgba(0,0,0,.1)}input::-webkit-validation-bubble-icon{display:none}::-webkit-validation-bubble-arrow{background-color:#9c2400;border:1px
solid #9c2400;-webkit-box-shadow:1px 1px 1px
rgba(0,0,0,.1)}.absent{color:#c00}.anchor{position:absolute;top:0;bottom:0;left:0;display:block;padding-right:6px;padding-left:30px;margin-left:-30px}.anchor:focus{outline:none}h1,h2,h3,h4,h5,h6{position:relative;margin-top:1em;margin-bottom:16px;font-weight:700;line-height:1.4}h1
.octicon-link,h2 .octicon-link,h3 .octicon-link,h4 .octicon-link,h5 .octicon-link,h6
.octicon-link{display:none;color:#000;vertical-align:middle}h1:hover .anchor,h2:hover .anchor,h3:hover .anchor,h4:hover
.anchor,h5:hover .anchor,h6:hover
.anchor{height:1em;padding-left:8px;margin-left:-30px;line-height:1;text-decoration:none}h1:hover .anchor
.octicon-link,h2:hover .anchor .octicon-link,h3:hover .anchor .octicon-link,h4:hover .anchor .octicon-link,h5:hover
.anchor .octicon-link,h6:hover .anchor .octicon-link{display:inline-block}h1 code,h1 tt,h2 code,h2 tt,h3 code,h3 tt,h4
code,h4 tt,h5 code,h5 tt,h6 code,h6
tt{font-size:inherit}h1{font-size:2.25em;line-height:1.2}h1,h2{padding-bottom:.3em;border-bottom:1px solid
#eee}h2{font-size:1.75em;line-height:1.225}h3{font-size:1.5em;line-height:1.43}h4{font-size:1.25em}h5,h6{font-size:1em}h6{color:#777}blockquote,dl,ol,p,pre,table,ul{margin-top:0;margin-bottom:16px}hr{height:4px;padding:0;margin:16px
0;background-color:#e7e7e7;border:0 none}ol,ul{padding-left:2em}ol.no-list,ul.no-list{padding:0;list-style-type:none}ol
ol,ol ul,ul ol,ul ul{margin-top:0;margin-bottom:0}li>p{margin-top:16px}dl,dl dt{padding:0}dl
dt{margin-top:16px;font-size:1em;font-style:italic;font-weight:700}dl dd{padding:0
16px;margin-bottom:16px}blockquote{padding:0 15px;color:#777;border-left:4px solid
#ddd}blockquote>:first-child{margin-top:0}blockquote>:last-child{margin-bottom:0}table{display:block;width:100%;overflow:auto;word-break:normal;word-break:keep-all}table
th{font-weight:700}table td,table th{padding:6px 13px;border:1px solid #ddd}table
tr{background-color:#fff;border-top:1px solid #ccc}table
tr:nth-child(2n){background-color:#f8f8f8}img{max-width:100%;box-sizing:border-box}span.frame,span.frame>span{display:block;overflow:hidden}span.frame>span{float:left;width:auto;padding:7px;margin:13px
0 0;border:1px solid #ddd}span.frame span img{display:block;float:left}span.frame span span{display:block;padding:5px 0
0;clear:both;color:#333}span.align-center{display:block;overflow:hidden;clear:both}span.align-center>span{display:block;margin:13px
auto 0;overflow:hidden;text-align:center}span.align-center span img{margin:0
auto;text-align:center}span.align-right{display:block;overflow:hidden;clear:both}span.align-right>span{display:block;margin:13px
0 0;overflow:hidden;text-align:right}span.align-right span
img{margin:0;text-align:right}span.float-left{display:block;float:left;margin-right:13px;overflow:hidden}span.float-left
span{margin:13px 0
0}span.float-right{display:block;float:right;margin-left:13px;overflow:hidden}span.float-right>span{display:block;margin:13px
auto
0;overflow:hidden;text-align:right}code,tt{padding:0;padding-top:.2em;padding-bottom:.2em;margin:0;font-size:85%;background-color:rgba(0,0,0,.04);border-radius:3px}code:after,code:before,tt:after,tt:before{letter-spacing:-.2em;content:"\00a0"}code
br,tt br{display:none}del
code{text-decoration:inherit;vertical-align:text-top}pre>code{padding:0;margin:0;font-size:100%;word-break:normal;white-space:pre;background:transparent;border:0}.highlight{margin-bottom:16px}.highlight
pre,pre{padding:16px;overflow:auto;font-size:85%;line-height:1.45;background-color:#f7f7f7;border-radius:3px}.highlight
pre{margin-bottom:0;word-break:normal}pre,pre code,pre tt{word-wrap:normal}pre code,pre
tt{display:inline;max-width:none;padding:0;margin:0;overflow:initial;line-height:inherit;background-color:transparent;border:0}pre
code:after,pre code:before,pre tt:after,pre
tt:before{content:normal}abbr,address,article,aside,audio,b,blockquote,body,canvas,caption,cite,code,dd,del,details,dfn,div,dl,dt,em,fieldset,figcaption,figure,footer,form,h1,h2,h3,h4,h5,h6,header,hgroup,html,i,iframe,img,ins,kbd,label,legend,li,mark,menu,nav,object,ol,p,pre,q,samp,section,small,span,strong,sub,summary,sup,table,tbody,td,tfoot,th,thead,time,tr,ul,var,video{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}article,aside,details,figcaption,figure,footer,header,hgroup,menu,nav,section{display:block}nav
ul{list-style:none}blockquote,q{quotes:none}blockquote:after,blockquote:before,q:after,q:before{content:'';content:none}a{margin:0;padding:0;font-size:100%;vertical-align:baseline;background:transparent}ins{text-decoration:none}ins,mark{background-color:#ff9;color:#000}mark{font-style:italic;font-weight:700}del{text-decoration:line-through}abbr[title],dfn[title]{border-bottom:1px
dotted;cursor:help}table{border-collapse:collapse;border-spacing:0}hr{display:block;height:1px;border:0;border-top:1px
solid #ccc;margin:1em
0;padding:0}input,select{vertical-align:middle}body{background-color:#fff;color:#123;font-size:14px;font-family:Helvetica
Neue,Helvetica,Segoe UI,Arial,freesans,sans-serif}main{max-width:1180px;padding:30px;margin:0 auto}@media
(min-width:900px){main h1+p{font-size:2em}}h1{font-weight:300;font-size:2em;line-height:1.4em;margin:.5em
0;font-family:Georgia,serif;-webkit-transition:color .4s;transition:color
.4s}h2{font-size:2em}h2,h3{font-weight:300;margin:30px
0}h3{font-size:1.8em}h4{font-size:1.6em}h4,h5{font-weight:300}h5{font-size:1.2em}h6{font-weight:300;font-size:1em}p{line-height:1.4em;font-size:1.2em;margin:15px
0}blockquote{border-left:5px solid
#ff1d55;background-color:#ffe9ee;padding:1em;margin-bottom:1em}.lightbox{background-color:rgba(3,121,196,.4);min-height:100vh;min-width:100vw;padding:30px}code{font:12px
Consolas,Liberation Mono,Menlo,Courier,monospace}p>code{color:#ff1d55}pre
code{display:block;background-color:#f7f7f7;padding:15px;overflow:auto;color:#123;line-height:1.4em}a{color:#ff1d55;text-decoration:none;-webkit-transition:color
.4s,background .4s;transition:color .4s,background .4s}a:hover{color:#e9003a}ol,ul{margin:7.5px;padding:7.5px 15px}ol
li,ul li{margin:7.5px 15px}.doc-parameters{list-style-type:none;padding:0}.doc-parameters
li{display:block;margin:0;margin-bottom:15px}.doc-parameters .example,.doc-parameters blockquote{border-left:5px solid
#0379c4;background-color:#96d5fd;color:#123;line-height:1em;font-size:1em;padding:1em;margin:0}.doc-parameters
.example{background-color:#c8e9fe}.doc-parameters
.parameter{display:block;padding:1em;background-color:#0379c4;color:#fff;margin:0}.doc-parameters .parameter
strong{display:inline-block;padding:0
.5em;border-radius:.25em;line-height:2em;background-color:#025a92}hr{height:.25em;padding:0;margin:24px
0;background-color:#f7f7f7;border:0}.teaser{display:-webkit-box;display:-ms-flexbox;display:flex;text-align:left;-ms-flex-line-pack:center;align-content:center;-ms-flex-wrap:wrap;flex-wrap:wrap;-webkit-box-pack:justify;-ms-flex-pack:justify;justify-content:space-between}.teaser
aside{-ms-flex-preferred-size:60%;flex-basis:60%;-ms-flex-item-align:center;-ms-grid-row-align:center;align-self:center;padding:30px}@media
(max-width:700px){.teaser aside{-ms-flex-preferred-size:100%;flex-basis:100%}}.teaser
.content{-ms-flex-preferred-size:40%;flex-basis:40%;-ms-flex-item-align:center;-ms-grid-row-align:center;align-self:center;color:dimgray;font-size:12px}@media
(max-width:700px){.teaser .content{-ms-flex-preferred-size:100%;flex-basis:100%}}.teaser
.content.content-full{-ms-flex-preferred-size:100%;flex-basis:100%}.teaser .content
h3{font-size:14px;text-transform:uppercase;font-weight:600;color:#123}.main-index{text-align:center}.main-index
amp-img{margin:15px auto;width:50%}@media (min-width:900px){.main-index
p{font-size:2em}}.breadcrumbs{padding:1em;background-color:#f7f7f7}.breadcrumbs
ul{display:block;margin:0;padding:0}.breadcrumbs ul li{display:inline-block;margin:0 .5em}.breadcrumbs ul
li:before{content:' / ';position:relative;margin-left:-.5em;color:dimgray}.breadcrumbs ul li
a{color:dimgray}.breadcrumbs ul li:last-child
a{color:#ff1d55}header{background-color:#000000;color:#fff;padding:30px;position:relative}header
.brand{display:inline-block;position:absolute;left:30px;top:20px;line-height:15px;text-transform:uppercase;padding:7.5px;font-size:1.4em}header
.brand:hover{background-color:#ff1d55;color:#fff}header
a{color:#fff;text-decoration:none;border-radius:7.5px;padding:7.5px}header
a:hover{text-decoration:none;background-color:#fff;color:#ff1d55}header nav
ul{padding:0;margin:0;display:block;text-align:right}header nav ul li{padding:0;margin:0
7.5px;display:inline-block}header nav ul li.hamburger{display:none}header nav ul li.hamburger
button{position:absolute;right:30px;top:20px;border:0;background-color:#fff;color:#ff1d55;font-weight:700;border-radius:50%;width:30px;height:30px;overflow:hidden;text-align:center;padding:0;margin:0}@media
(max-width:900px){header nav ul li{display:none}header nav ul
li.hamburger{display:inline-block}}.sidebarNavigation{width:210px;max-width:95%}.sidebarNavigation
ul{padding:0;margin:0}.sidebarNavigation ul li{display:block}.sidebarNavigation ul li
a{display:block;line-height:1.4em;padding:7.5px}footer{margin:60px
auto;display:-webkit-box;display:-ms-flexbox;display:flex;-ms-flex-line-pack:center;align-content:center;-ms-flex-wrap:wrap;flex-wrap:wrap;-webkit-box-pack:justify;-ms-flex-pack:justify;justify-content:space-between;max-width:1180px;padding:30px;font-size:12px}footer
a:hover{text-decoration:none}footer strong{text-transform:uppercase;margin-bottom:15px;display:block}footer strong
a{color:#1d1d1d}footer ul{display:block;padding:0;margin:0}footer ul li{display:block;line-height:1.4em;padding:7.5px
0;margin:0}footer ul li a{color:dimgray}footer
.quarter-section{margin-bottom:30px;-ms-flex-preferred-size:25%;flex-basis:25%}@media (max-width:900px){footer
.quarter-section{-ms-flex-preferred-size:33%;flex-basis:33%}}@media (max-width:700px){footer
.quarter-section{-ms-flex-preferred-size:50%;flex-basis:50%}}@media (max-width:500px){footer
.quarter-section{-ms-flex-preferred-size:100%;flex-basis:100%}}.boxes{display:-webkit-box;display:-ms-flexbox;display:flex;-ms-flex-line-pack:center;align-content:center;-ms-flex-wrap:wrap;flex-wrap:wrap;-webkit-box-pack:justify;-ms-flex-pack:justify;justify-content:space-between;font-size:12px}.boxes
.box{-ms-flex-preferred-size:30%;flex-basis:30%;background-color:#f7f7f7;padding:30px;margin:7.5px
0;text-align:left;font-size:12px}.boxes .box h3{font-size:12px;line-height:1em;padding:0;margin:0}.boxes .box
a{padding:0;color:#ff1d55}.boxes .box p{color:dimgray;font-size:12px;margin:7.5px 0}@media (max-width:900px){.boxes
.box{-ms-flex-preferred-size:45%;flex-basis:45%}}@media (max-width:500px){.boxes
.box{-ms-flex-preferred-size:100%;flex-basis:100%}}

.fixed-container {
  position: relative;
  width: 100%;
  height: 300px;
  margin: auto;
}

amp-img.contain img {
  object-fit: contain;
}

.footnotes {
  overflow-wrap: break-word;
}

    </style>


</head>

<body>

<main>
  
  <section class="container page">
  <article>
    <header>
      <h1>一行一行源码分析清楚 AbstractQueuedSynchronizer (一)</h1>
    </header>

    <p>在分析 Java 并发包 java.util.concurrent 源码的时候，少不了需要了解 AbstractQueuedSynchronizer（以下简写AQS）这个抽象类，因为它是 Java 并发包的基础工具类，是实现 ReentrantLock、CountDownLatch、Semaphore、FutureTask 等类的基础。</p>
<p>Google 一下 AbstractQueuedSynchronizer，我们可以找到很多关于 AQS 的介绍，但是很多都没有介绍清楚，因为大部分文章没有把其中的一些关键的细节说清楚。</p>
<p>本文将从 ReentrantLock 的公平锁源码出发，分析下 AbstractQueuedSynchronizer 这个类是怎么工作的，希望能给大家提供一些简单的帮助。</p>
<p>申明以下几点：</p>
<ol>
<li>本文有点长，但还是挺简单，主要面向读者对象为并发编程的初学者，或者想要阅读 Java 并发包源码的开发者。对于新手来说，可能需要花好几个小时才能完全看懂，但是这时间肯定是值得的。</li>
<li>源码环境 JDK1.7（1.8没啥变化），看到不懂或有疑惑的部分，最好能自己打开源码看看。Doug Lea 大神的代码写得真心不错。</li>
<li>本文不分析共享模式，这样可以给读者减少很多负担，<a href="https://www.zhouyi.tech/archives/%E4%B8%80%E8%A1%8C%E4%B8%80%E8%A1%8C%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E6%B8%85%E6%A5%9A-abstractqueuedsynchronizer-%E4%B8%89">第三篇文章</a>对共享模式进行了分析。而且也不分析 condition 部分，所以应该说很容易就可以看懂了。</li>
<li>本文大量使用我们平时用得最多的 ReentrantLock 的概念，本质上来说是不正确的，读者应该清楚，AQS 不仅仅用来实现可重入锁，只是希望读者可以用锁来联想 AQS 的使用场景，降低阅读压力。</li>
<li>ReentrantLock 的公平锁和非公平锁只有一点点区别，<a href="https://www.zhouyi.tech/archives/%E4%B8%80%E8%A1%8C%E4%B8%80%E8%A1%8C%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E6%B8%85%E6%A5%9A-abstractqueuedsynchronizer-%E4%BA%8C">第二篇文章</a>做了介绍。</li>
<li>评论区有读者反馈本文直接用代码说不友好，应该多配点流程图，这篇文章确实有这个问题。但是作为过来人，我想告诉大家，对于 AQS 来说，形式真的不重要，重要的是把细节说清楚。</li>
</ol>
<h2 id="aqs-结构">AQS 结构</h2>
<p>先来看看 AQS 有哪些属性，搞清楚这些基本就知道 AQS 是什么套路了，毕竟可以猜嘛！</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#007f7f">// 头结点，你直接把它当做 当前持有锁的线程 可能是最好理解的
</span><span style="color:#007f7f"></span><span style="color:#fff;font-weight:bold">private</span> <span style="color:#fff;font-weight:bold">transient</span> <span style="color:#fff;font-weight:bold">volatile</span> Node head;

<span style="color:#007f7f">// 阻塞的尾节点，每个新的节点进来，都插入到最后，也就形成了一个链表
</span><span style="color:#007f7f"></span><span style="color:#fff;font-weight:bold">private</span> <span style="color:#fff;font-weight:bold">transient</span> <span style="color:#fff;font-weight:bold">volatile</span> Node tail;

<span style="color:#007f7f">// 这个是最重要的，代表当前锁的状态，0代表没有被占用，大于 0 代表有线程持有当前锁
</span><span style="color:#007f7f">// 这个值可以大于 1，是因为锁可以重入，每次重入都加上 1
</span><span style="color:#007f7f"></span><span style="color:#fff;font-weight:bold">private</span> <span style="color:#fff;font-weight:bold">volatile</span> <span style="color:#fff;font-weight:bold">int</span> state;

<span style="color:#007f7f">// 代表当前持有独占锁的线程，举个最重要的使用例子，因为锁可以重入
</span><span style="color:#007f7f">// reentrantLock.lock()可以嵌套调用多次，所以每次用这个来判断当前线程是否已经拥有了锁
</span><span style="color:#007f7f">// if (currentThread == getExclusiveOwnerThread()) {state++}
</span><span style="color:#007f7f"></span><span style="color:#fff;font-weight:bold">private</span> <span style="color:#fff;font-weight:bold">transient</span> Thread exclusiveOwnerThread; <span style="color:#007f7f">//继承自AbstractOwnableSynchronizer
</span></code></pre></div><p>怎么样，看样子应该是很简单的吧，毕竟也就四个属性啊。</p>
<p>AbstractQueuedSynchronizer 的等待队列示意如下所示，注意了，之后分析过程中所说的 queue，也就是阻塞队列<strong>不包含 head，不包含 head，不包含 head</strong>。</p>
<p><img src="http://img.zhouyi.tech/note/aqs-0-7307b5fadcb74cb3b111e29e6c0ed80b.png" alt="aqs-0"></p>
<p>等待队列中每个线程被包装成一个 Node 实例，数据结构是链表，一起看看源码吧：</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#fff;font-weight:bold">static</span> <span style="color:#fff;font-weight:bold">final</span> <span style="color:#fff;font-weight:bold">class</span> Node {
    <span style="color:#007f7f">// 标识节点当前在共享模式下
</span><span style="color:#007f7f"></span>    <span style="color:#fff;font-weight:bold">static</span> <span style="color:#fff;font-weight:bold">final</span> Node SHARED = <span style="color:#fff;font-weight:bold">new</span> Node();
    <span style="color:#007f7f">// 标识节点当前在独占模式下
</span><span style="color:#007f7f"></span>    <span style="color:#fff;font-weight:bold">static</span> <span style="color:#fff;font-weight:bold">final</span> Node EXCLUSIVE = <span style="color:#fff;font-weight:bold">null</span>;
  
    <span style="color:#007f7f">// ======== 下面的几个int常量是给waitStatus用的 ===========
</span><span style="color:#007f7f"></span>    <span style="color:#007f7f">/** waitStatus value to indicate thread has cancelled */</span>
    <span style="color:#007f7f">// 代码此线程取消了争抢这个锁
</span><span style="color:#007f7f"></span>    <span style="color:#fff;font-weight:bold">static</span> <span style="color:#fff;font-weight:bold">final</span> <span style="color:#fff;font-weight:bold">int</span> CANCELLED =  1;
    <span style="color:#007f7f">/** waitStatus value to indicate successor&#39;s thread needs unparking */</span>
    <span style="color:#007f7f">// 官方的描述是，其表示当前node的后继节点对应的线程需要被唤醒
</span><span style="color:#007f7f"></span>    <span style="color:#fff;font-weight:bold">static</span> <span style="color:#fff;font-weight:bold">final</span> <span style="color:#fff;font-weight:bold">int</span> SIGNAL    = -1;
    <span style="color:#007f7f">/** waitStatus value to indicate thread is waiting on condition */</span>
    <span style="color:#007f7f">// 本文不分析condition，所以略过吧，下一篇文章会介绍这个
</span><span style="color:#007f7f"></span>    <span style="color:#fff;font-weight:bold">static</span> <span style="color:#fff;font-weight:bold">final</span> <span style="color:#fff;font-weight:bold">int</span> CONDITION = -2;
    <span style="color:#007f7f">/**
</span><span style="color:#007f7f">     * waitStatus value to indicate the next acquireShared should
</span><span style="color:#007f7f">     * unconditionally propagate
</span><span style="color:#007f7f">     */</span>
    <span style="color:#007f7f">// 同样的不分析，略过吧
</span><span style="color:#007f7f"></span>    <span style="color:#fff;font-weight:bold">static</span> <span style="color:#fff;font-weight:bold">final</span> <span style="color:#fff;font-weight:bold">int</span> PROPAGATE = -3;
    <span style="color:#007f7f">// =====================================================
</span><span style="color:#007f7f"></span>  
  
    <span style="color:#007f7f">// 取值为上面的1、-1、-2、-3，或者0(以后会讲到)
</span><span style="color:#007f7f"></span>    <span style="color:#007f7f">// 这么理解，暂时只需要知道如果这个值 大于0 代表此线程取消了等待，
</span><span style="color:#007f7f"></span>    <span style="color:#007f7f">//    ps: 半天抢不到锁，不抢了，ReentrantLock是可以指定timeouot的。。。
</span><span style="color:#007f7f"></span>    <span style="color:#fff;font-weight:bold">volatile</span> <span style="color:#fff;font-weight:bold">int</span> waitStatus;
    <span style="color:#007f7f">// 前驱节点的引用
</span><span style="color:#007f7f"></span>    <span style="color:#fff;font-weight:bold">volatile</span> Node prev;
    <span style="color:#007f7f">// 后继节点的引用
</span><span style="color:#007f7f"></span>    <span style="color:#fff;font-weight:bold">volatile</span> Node next;
    <span style="color:#007f7f">// 这个就是线程本尊
</span><span style="color:#007f7f"></span>    <span style="color:#fff;font-weight:bold">volatile</span> Thread thread;

}
</code></pre></div><p>Node 的数据结构其实也挺简单的，就是 thread + waitStatus + pre + next 四个属性而已，大家先要有这个概念在心里。</p>
<p>上面的是基础知识，后面会多次用到，心里要时刻记着它们，心里想着这个结构图就可以了。下面，我们开始说 ReentrantLock 的公平锁。再次强调，我说的阻塞队列不包含 head 节点。</p>
<p><img src="http://img.zhouyi.tech/note/aqs-0-7307b5fadcb74cb3b111e29e6c0ed80b.png" alt="aqs-0"></p>
<p>首先，我们先看下 ReentrantLock 的使用方式。</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#007f7f">// 我用个web开发中的service概念吧
</span><span style="color:#007f7f"></span><span style="color:#fff;font-weight:bold">public</span> <span style="color:#fff;font-weight:bold">class</span> OrderService {
    <span style="color:#007f7f">// 使用static，这样每个线程拿到的是同一把锁，当然，spring mvc中service默认就是单例，别纠结这个
</span><span style="color:#007f7f"></span>    <span style="color:#fff;font-weight:bold">private</span> <span style="color:#fff;font-weight:bold">static</span> ReentrantLock reentrantLock = <span style="color:#fff;font-weight:bold">new</span> ReentrantLock(<span style="color:#fff;font-weight:bold">true</span>);
    
    <span style="color:#fff;font-weight:bold">public</span> <span style="color:#fff;font-weight:bold">void</span> createOrder() {
        <span style="color:#007f7f">// 比如我们同一时间，只允许一个线程创建订单
</span><span style="color:#007f7f"></span>        reentrantLock.<span style="color:#007f7f">lock</span>();
        <span style="color:#007f7f">// 通常，lock 之后紧跟着 try 语句
</span><span style="color:#007f7f"></span>        <span style="color:#fff;font-weight:bold">try</span> {
            <span style="color:#007f7f">// 这块代码同一时间只能有一个线程进来(获取到锁的线程)，
</span><span style="color:#007f7f"></span>            <span style="color:#007f7f">// 其他的线程在lock()方法上阻塞，等待获取到锁，再进来
</span><span style="color:#007f7f"></span>            <span style="color:#007f7f">// 执行代码...
</span><span style="color:#007f7f"></span>            <span style="color:#007f7f">// 执行代码...
</span><span style="color:#007f7f"></span>            <span style="color:#007f7f">// 执行代码...
</span><span style="color:#007f7f"></span>        } <span style="color:#fff;font-weight:bold">finally</span> {
            <span style="color:#007f7f">// 释放锁
</span><span style="color:#007f7f"></span>            reentrantLock.<span style="color:#007f7f">unlock</span>();
        }
    }
}
</code></pre></div><p>ReentrantLock 在内部用了内部类 Sync 来管理锁，所以真正的获取锁和释放锁是由 Sync 的实现类来控制的。</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#fff;font-weight:bold">abstract</span> <span style="color:#fff;font-weight:bold">static</span> <span style="color:#fff;font-weight:bold">class</span> Sync <span style="color:#fff;font-weight:bold">extends</span> AbstractQueuedSynchronizer {
}
</code></pre></div><p>Sync 有两个实现，分别为 NonfairSync（非公平锁）和 FairSync（公平锁），我们看 FairSync 部分。</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#fff;font-weight:bold">public</span> ReentrantLock(<span style="color:#fff;font-weight:bold">boolean</span> fair) {
    sync = fair ? <span style="color:#fff;font-weight:bold">new</span> FairSync() : <span style="color:#fff;font-weight:bold">new</span> NonfairSync();
}
</code></pre></div><h2 id="线程抢锁">线程抢锁</h2>
<p>很多人肯定开始嫌弃上面废话太多了，下面跟着代码走，我就不废话了。</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#fff;font-weight:bold">static</span> <span style="color:#fff;font-weight:bold">final</span> <span style="color:#fff;font-weight:bold">class</span> FairSync <span style="color:#fff;font-weight:bold">extends</span> Sync {
    <span style="color:#fff;font-weight:bold">private</span> <span style="color:#fff;font-weight:bold">static</span> <span style="color:#fff;font-weight:bold">final</span> <span style="color:#fff;font-weight:bold">long</span> serialVersionUID = -3000897897090466540L;
  	<span style="color:#007f7f">// 争锁
</span><span style="color:#007f7f"></span>    <span style="color:#fff;font-weight:bold">final</span> <span style="color:#fff;font-weight:bold">void</span> lock() {
        acquire(1);
    }
  	<span style="color:#007f7f">// 来自父类AQS，我直接贴过来这边，下面分析的时候同样会这样做，不会给读者带来阅读压力
</span><span style="color:#007f7f"></span>    <span style="color:#007f7f">// 我们看到，这个方法，如果tryAcquire(arg) 返回true, 也就结束了。
</span><span style="color:#007f7f"></span>    <span style="color:#007f7f">// 否则，acquireQueued方法会将线程压到队列中
</span><span style="color:#007f7f"></span>    <span style="color:#fff;font-weight:bold">public</span> <span style="color:#fff;font-weight:bold">final</span> <span style="color:#fff;font-weight:bold">void</span> acquire(<span style="color:#fff;font-weight:bold">int</span> arg) { <span style="color:#007f7f">// 此时 arg == 1
</span><span style="color:#007f7f"></span>        <span style="color:#007f7f">// 首先调用tryAcquire(1)一下，名字上就知道，这个只是试一试
</span><span style="color:#007f7f"></span>        <span style="color:#007f7f">// 因为有可能直接就成功了呢，也就不需要进队列排队了，
</span><span style="color:#007f7f"></span>        <span style="color:#007f7f">// 对于公平锁的语义就是：本来就没人持有锁，根本没必要进队列等待(又是挂起，又是等待被唤醒的)
</span><span style="color:#007f7f"></span>        <span style="color:#fff;font-weight:bold">if</span> (!tryAcquire(arg) &amp;&amp;
            <span style="color:#007f7f">// tryAcquire(arg)没有成功，这个时候需要把当前线程挂起，放到阻塞队列中。
</span><span style="color:#007f7f"></span>            acquireQueued(addWaiter(Node.<span style="color:#007f7f">EXCLUSIVE</span>), arg)) {
              selfInterrupt();
        }
    }

    <span style="color:#007f7f">/**
</span><span style="color:#007f7f">     * Fair version of tryAcquire.  Don&#39;t grant access unless
</span><span style="color:#007f7f">     * recursive call or no waiters or is first.
</span><span style="color:#007f7f">     */</span>
    <span style="color:#007f7f">// 尝试直接获取锁，返回值是boolean，代表是否获取到锁
</span><span style="color:#007f7f"></span>    <span style="color:#007f7f">// 返回true：1.没有线程在等待锁；2.重入锁，线程本来就持有锁，也就可以理所当然可以直接获取
</span><span style="color:#007f7f"></span>    <span style="color:#fff;font-weight:bold">protected</span> <span style="color:#fff;font-weight:bold">final</span> <span style="color:#fff;font-weight:bold">boolean</span> tryAcquire(<span style="color:#fff;font-weight:bold">int</span> acquires) {
        <span style="color:#fff;font-weight:bold">final</span> Thread current = Thread.<span style="color:#007f7f">currentThread</span>();
        <span style="color:#fff;font-weight:bold">int</span> c = getState();
        <span style="color:#007f7f">// state == 0 此时此刻没有线程持有锁
</span><span style="color:#007f7f"></span>        <span style="color:#fff;font-weight:bold">if</span> (c == 0) {
            <span style="color:#007f7f">// 虽然此时此刻锁是可以用的，但是这是公平锁，既然是公平，就得讲究先来后到，
</span><span style="color:#007f7f"></span>            <span style="color:#007f7f">// 看看有没有别人在队列中等了半天了
</span><span style="color:#007f7f"></span>            <span style="color:#fff;font-weight:bold">if</span> (!hasQueuedPredecessors() &amp;&amp;
                <span style="color:#007f7f">// 如果没有线程在等待，那就用CAS尝试一下，成功了就获取到锁了，
</span><span style="color:#007f7f"></span>                <span style="color:#007f7f">// 不成功的话，只能说明一个问题，就在刚刚几乎同一时刻有个线程抢先了 =_=
</span><span style="color:#007f7f"></span>                <span style="color:#007f7f">// 因为刚刚还没人的，我判断过了
</span><span style="color:#007f7f"></span>                compareAndSetState(0, acquires)) {
              
                <span style="color:#007f7f">// 到这里就是获取到锁了，标记一下，告诉大家，现在是我占用了锁
</span><span style="color:#007f7f"></span>                setExclusiveOwnerThread(current);
                <span style="color:#fff;font-weight:bold">return</span> <span style="color:#fff;font-weight:bold">true</span>;
            }
        }
      	<span style="color:#007f7f">// 会进入这个else if分支，说明是重入了，需要操作：state=state+1
</span><span style="color:#007f7f"></span>        <span style="color:#007f7f">// 这里不存在并发问题
</span><span style="color:#007f7f"></span>        <span style="color:#fff;font-weight:bold">else</span> <span style="color:#fff;font-weight:bold">if</span> (current == getExclusiveOwnerThread()) {
            <span style="color:#fff;font-weight:bold">int</span> nextc = c + acquires;
            <span style="color:#fff;font-weight:bold">if</span> (nextc &lt; 0)
                <span style="color:#fff;font-weight:bold">throw</span> <span style="color:#fff;font-weight:bold">new</span> Error(<span style="color:#0ff;font-weight:bold">&#34;Maximum lock count exceeded&#34;</span>);
            setState(nextc);
            <span style="color:#fff;font-weight:bold">return</span> <span style="color:#fff;font-weight:bold">true</span>;
        }
        <span style="color:#007f7f">// 如果到这里，说明前面的if和else if都没有返回true，说明没有获取到锁
</span><span style="color:#007f7f"></span>        <span style="color:#007f7f">// 回到上面一个外层调用方法继续看:
</span><span style="color:#007f7f"></span>        <span style="color:#007f7f">// if (!tryAcquire(arg) 
</span><span style="color:#007f7f"></span>        <span style="color:#007f7f">//        &amp;&amp; acquireQueued(addWaiter(Node.EXCLUSIVE), arg)) 
</span><span style="color:#007f7f"></span>        <span style="color:#007f7f">//     selfInterrupt();
</span><span style="color:#007f7f"></span>        <span style="color:#fff;font-weight:bold">return</span> <span style="color:#fff;font-weight:bold">false</span>;
    }
  
    <span style="color:#007f7f">// 假设tryAcquire(arg) 返回false，那么代码将执行：
</span><span style="color:#007f7f"></span>  	<span style="color:#007f7f">//		acquireQueued(addWaiter(Node.EXCLUSIVE), arg)，
</span><span style="color:#007f7f"></span>    <span style="color:#007f7f">// 这个方法，首先需要执行：addWaiter(Node.EXCLUSIVE)
</span><span style="color:#007f7f"></span>  
    <span style="color:#007f7f">/**
</span><span style="color:#007f7f">     * Creates and enqueues node for current thread and given mode.
</span><span style="color:#007f7f">     *
</span><span style="color:#007f7f">     * @param mode Node.EXCLUSIVE for exclusive, Node.SHARED for shared
</span><span style="color:#007f7f">     * @return the new node
</span><span style="color:#007f7f">     */</span>
    <span style="color:#007f7f">// 此方法的作用是把线程包装成node，同时进入到队列中
</span><span style="color:#007f7f"></span>    <span style="color:#007f7f">// 参数mode此时是Node.EXCLUSIVE，代表独占模式
</span><span style="color:#007f7f"></span>    <span style="color:#fff;font-weight:bold">private</span> Node addWaiter(Node mode) {
        Node node = <span style="color:#fff;font-weight:bold">new</span> Node(Thread.<span style="color:#007f7f">currentThread</span>(), mode);
        <span style="color:#007f7f">// Try the fast path of enq; backup to full enq on failure
</span><span style="color:#007f7f"></span>        <span style="color:#007f7f">// 以下几行代码想把当前node加到链表的最后面去，也就是进到阻塞队列的最后
</span><span style="color:#007f7f"></span>        Node pred = tail;
      
        <span style="color:#007f7f">// tail!=null =&gt; 队列不为空(tail==head的时候，其实队列是空的，不过不管这个吧)
</span><span style="color:#007f7f"></span>        <span style="color:#fff;font-weight:bold">if</span> (pred != <span style="color:#fff;font-weight:bold">null</span>) { 
            <span style="color:#007f7f">// 将当前的队尾节点，设置为自己的前驱 
</span><span style="color:#007f7f"></span>            node.<span style="color:#007f7f">prev</span> = pred; 
            <span style="color:#007f7f">// 用CAS把自己设置为队尾, 如果成功后，tail == node 了，这个节点成为阻塞队列新的尾巴
</span><span style="color:#007f7f"></span>            <span style="color:#fff;font-weight:bold">if</span> (compareAndSetTail(pred, node)) { 
                <span style="color:#007f7f">// 进到这里说明设置成功，当前node==tail, 将自己与之前的队尾相连，
</span><span style="color:#007f7f"></span>                <span style="color:#007f7f">// 上面已经有 node.prev = pred，加上下面这句，也就实现了和之前的尾节点双向连接了
</span><span style="color:#007f7f"></span>                pred.<span style="color:#007f7f">next</span> = node;
                <span style="color:#007f7f">// 线程入队了，可以返回了
</span><span style="color:#007f7f"></span>                <span style="color:#fff;font-weight:bold">return</span> node;
            }
        }
        <span style="color:#007f7f">// 仔细看看上面的代码，如果会到这里，
</span><span style="color:#007f7f"></span>        <span style="color:#007f7f">// 说明 pred==null(队列是空的) 或者 CAS失败(有线程在竞争入队)
</span><span style="color:#007f7f"></span>        <span style="color:#007f7f">// 读者一定要跟上思路，如果没有跟上，建议先不要往下读了，往回仔细看，否则会浪费时间的
</span><span style="color:#007f7f"></span>        enq(node);
        <span style="color:#fff;font-weight:bold">return</span> node;
    }
  
    <span style="color:#007f7f">/**
</span><span style="color:#007f7f">     * Inserts node into queue, initializing if necessary. See picture above.
</span><span style="color:#007f7f">     * @param node the node to insert
</span><span style="color:#007f7f">     * @return node&#39;s predecessor
</span><span style="color:#007f7f">     */</span>
    <span style="color:#007f7f">// 采用自旋的方式入队
</span><span style="color:#007f7f"></span>    <span style="color:#007f7f">// 之前说过，到这个方法只有两种可能：等待队列为空，或者有线程竞争入队，
</span><span style="color:#007f7f"></span>    <span style="color:#007f7f">// 自旋在这边的语义是：CAS设置tail过程中，竞争一次竞争不到，我就多次竞争，总会排到的
</span><span style="color:#007f7f"></span>    <span style="color:#fff;font-weight:bold">private</span> Node enq(<span style="color:#fff;font-weight:bold">final</span> Node node) {
        <span style="color:#fff;font-weight:bold">for</span> (;;) {
            Node t = tail;
            <span style="color:#007f7f">// 之前说过，队列为空也会进来这里
</span><span style="color:#007f7f"></span>            <span style="color:#fff;font-weight:bold">if</span> (t == <span style="color:#fff;font-weight:bold">null</span>) { <span style="color:#007f7f">// Must initialize
</span><span style="color:#007f7f"></span>                <span style="color:#007f7f">// 初始化head节点
</span><span style="color:#007f7f"></span>                <span style="color:#007f7f">// 细心的读者会知道原来 head 和 tail 初始化的时候都是 null 的
</span><span style="color:#007f7f"></span>                <span style="color:#007f7f">// 还是一步CAS，你懂的，现在可能是很多线程同时进来呢
</span><span style="color:#007f7f"></span>                <span style="color:#fff;font-weight:bold">if</span> (compareAndSetHead(<span style="color:#fff;font-weight:bold">new</span> Node()))
                    <span style="color:#007f7f">// 给后面用：这个时候head节点的waitStatus==0, 看new Node()构造方法就知道了
</span><span style="color:#007f7f"></span>                  
                    <span style="color:#007f7f">// 这个时候有了head，但是tail还是null，设置一下，
</span><span style="color:#007f7f"></span>                    <span style="color:#007f7f">// 把tail指向head，放心，马上就有线程要来了，到时候tail就要被抢了
</span><span style="color:#007f7f"></span>                    <span style="color:#007f7f">// 注意：这里只是设置了tail=head，这里可没return哦，没有return，没有return
</span><span style="color:#007f7f"></span>                    <span style="color:#007f7f">// 所以，设置完了以后，继续for循环，下次就到下面的else分支了
</span><span style="color:#007f7f"></span>                    tail = head;
            } <span style="color:#fff;font-weight:bold">else</span> {
                <span style="color:#007f7f">// 下面几行，和上一个方法 addWaiter 是一样的，
</span><span style="color:#007f7f"></span>                <span style="color:#007f7f">// 只是这个套在无限循环里，反正就是将当前线程排到队尾，有线程竞争的话排不上重复排
</span><span style="color:#007f7f"></span>                node.<span style="color:#007f7f">prev</span> = t;
                <span style="color:#fff;font-weight:bold">if</span> (compareAndSetTail(t, node)) {
                    t.<span style="color:#007f7f">next</span> = node;
                    <span style="color:#fff;font-weight:bold">return</span> t;
                }
            }
        }
    }
    
  
    <span style="color:#007f7f">// 现在，又回到这段代码了
</span><span style="color:#007f7f"></span>    <span style="color:#007f7f">// if (!tryAcquire(arg) 
</span><span style="color:#007f7f"></span>    <span style="color:#007f7f">//        &amp;&amp; acquireQueued(addWaiter(Node.EXCLUSIVE), arg)) 
</span><span style="color:#007f7f"></span>    <span style="color:#007f7f">//     selfInterrupt();
</span><span style="color:#007f7f"></span>    
    <span style="color:#007f7f">// 下面这个方法，参数node，经过addWaiter(Node.EXCLUSIVE)，此时已经进入阻塞队列
</span><span style="color:#007f7f"></span>    <span style="color:#007f7f">// 注意一下：如果acquireQueued(addWaiter(Node.EXCLUSIVE), arg))返回true的话，
</span><span style="color:#007f7f"></span>    <span style="color:#007f7f">// 意味着上面这段代码将进入selfInterrupt()，所以正常情况下，下面应该返回false
</span><span style="color:#007f7f"></span>    <span style="color:#007f7f">// 这个方法非常重要，应该说真正的线程挂起，然后被唤醒后去获取锁，都在这个方法里了
</span><span style="color:#007f7f"></span>    <span style="color:#fff;font-weight:bold">final</span> <span style="color:#fff;font-weight:bold">boolean</span> acquireQueued(<span style="color:#fff;font-weight:bold">final</span> Node node, <span style="color:#fff;font-weight:bold">int</span> arg) {
        <span style="color:#fff;font-weight:bold">boolean</span> failed = <span style="color:#fff;font-weight:bold">true</span>;
        <span style="color:#fff;font-weight:bold">try</span> {
            <span style="color:#fff;font-weight:bold">boolean</span> interrupted = <span style="color:#fff;font-weight:bold">false</span>;
            <span style="color:#fff;font-weight:bold">for</span> (;;) {
                <span style="color:#fff;font-weight:bold">final</span> Node p = node.<span style="color:#007f7f">predecessor</span>();
                <span style="color:#007f7f">// p == head 说明当前节点虽然进到了阻塞队列，但是是阻塞队列的第一个，因为它的前驱是head
</span><span style="color:#007f7f"></span>                <span style="color:#007f7f">// 注意，阻塞队列不包含head节点，head一般指的是占有锁的线程，head后面的才称为阻塞队列
</span><span style="color:#007f7f"></span>                <span style="color:#007f7f">// 所以当前节点可以去试抢一下锁
</span><span style="color:#007f7f"></span>                <span style="color:#007f7f">// 这里我们说一下，为什么可以去试试：
</span><span style="color:#007f7f"></span>                <span style="color:#007f7f">// 首先，它是队头，这个是第一个条件，其次，当前的head有可能是刚刚初始化的node，
</span><span style="color:#007f7f"></span>                <span style="color:#007f7f">// enq(node) 方法里面有提到，head是延时初始化的，而且new Node()的时候没有设置任何线程
</span><span style="color:#007f7f"></span>                <span style="color:#007f7f">// 也就是说，当前的head不属于任何一个线程，所以作为队头，可以去试一试，
</span><span style="color:#007f7f"></span>                <span style="color:#007f7f">// tryAcquire已经分析过了, 忘记了请往前看一下，就是简单用CAS试操作一下state
</span><span style="color:#007f7f"></span>                <span style="color:#fff;font-weight:bold">if</span> (p == head &amp;&amp; tryAcquire(arg)) {
                    setHead(node);
                    p.<span style="color:#007f7f">next</span> = <span style="color:#fff;font-weight:bold">null</span>; <span style="color:#007f7f">// help GC
</span><span style="color:#007f7f"></span>                    failed = <span style="color:#fff;font-weight:bold">false</span>;
                    <span style="color:#fff;font-weight:bold">return</span> interrupted;
                }
                <span style="color:#007f7f">// 到这里，说明上面的if分支没有成功，要么当前node本来就不是队头，
</span><span style="color:#007f7f"></span>                <span style="color:#007f7f">// 要么就是tryAcquire(arg)没有抢赢别人，继续往下看
</span><span style="color:#007f7f"></span>                <span style="color:#fff;font-weight:bold">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;
                    parkAndCheckInterrupt())
                    interrupted = <span style="color:#fff;font-weight:bold">true</span>;
            }
        } <span style="color:#fff;font-weight:bold">finally</span> {
            <span style="color:#007f7f">// 什么时候 failed 会为 true???
</span><span style="color:#007f7f"></span>            <span style="color:#007f7f">// tryAcquire() 方法抛异常的情况
</span><span style="color:#007f7f"></span>            <span style="color:#fff;font-weight:bold">if</span> (failed)
                cancelAcquire(node);
        }
    }
  
    <span style="color:#007f7f">/**
</span><span style="color:#007f7f">     * Checks and updates status for a node that failed to acquire.
</span><span style="color:#007f7f">     * Returns true if thread should block. This is the main signal
</span><span style="color:#007f7f">     * control in all acquire loops.  Requires that pred == node.prev
</span><span style="color:#007f7f">     *
</span><span style="color:#007f7f">     * @param pred node&#39;s predecessor holding status
</span><span style="color:#007f7f">     * @param node the node
</span><span style="color:#007f7f">     * @return {@code true} if thread should block
</span><span style="color:#007f7f">     */</span>
    <span style="color:#007f7f">// 刚刚说过，会到这里就是没有抢到锁呗，这个方法说的是：&#34;当前线程没有抢到锁，是否需要挂起当前线程？&#34;
</span><span style="color:#007f7f"></span>    <span style="color:#007f7f">// 第一个参数是前驱节点，第二个参数才是代表当前线程的节点
</span><span style="color:#007f7f"></span>    <span style="color:#fff;font-weight:bold">private</span> <span style="color:#fff;font-weight:bold">static</span> <span style="color:#fff;font-weight:bold">boolean</span> shouldParkAfterFailedAcquire(Node pred, Node node) {
        <span style="color:#fff;font-weight:bold">int</span> ws = pred.<span style="color:#007f7f">waitStatus</span>;
        <span style="color:#007f7f">// 前驱节点的 waitStatus == -1 ，说明前驱节点状态正常，当前线程需要挂起，直接可以返回true
</span><span style="color:#007f7f"></span>        <span style="color:#fff;font-weight:bold">if</span> (ws == Node.<span style="color:#007f7f">SIGNAL</span>)
            <span style="color:#007f7f">/*
</span><span style="color:#007f7f">             * This node has already set status asking a release
</span><span style="color:#007f7f">             * to signal it, so it can safely park.
</span><span style="color:#007f7f">             */</span>
            <span style="color:#fff;font-weight:bold">return</span> <span style="color:#fff;font-weight:bold">true</span>;
        
        <span style="color:#007f7f">// 前驱节点 waitStatus大于0 ，之前说过，大于0 说明前驱节点取消了排队。
</span><span style="color:#007f7f"></span>        <span style="color:#007f7f">// 这里需要知道这点：进入阻塞队列排队的线程会被挂起，而唤醒的操作是由前驱节点完成的。
</span><span style="color:#007f7f"></span>        <span style="color:#007f7f">// 所以下面这块代码说的是将当前节点的prev指向waitStatus&lt;=0的节点，
</span><span style="color:#007f7f"></span>        <span style="color:#007f7f">// 简单说，就是为了找个好爹，因为你还得依赖它来唤醒呢，如果前驱节点取消了排队，
</span><span style="color:#007f7f"></span>        <span style="color:#007f7f">// 找前驱节点的前驱节点做爹，往前遍历总能找到一个好爹的
</span><span style="color:#007f7f"></span>        <span style="color:#fff;font-weight:bold">if</span> (ws &gt; 0) {
            <span style="color:#007f7f">/*
</span><span style="color:#007f7f">             * Predecessor was cancelled. Skip over predecessors and
</span><span style="color:#007f7f">             * indicate retry.
</span><span style="color:#007f7f">             */</span>
            <span style="color:#fff;font-weight:bold">do</span> {
                node.<span style="color:#007f7f">prev</span> = pred = pred.<span style="color:#007f7f">prev</span>;
            } <span style="color:#fff;font-weight:bold">while</span> (pred.<span style="color:#007f7f">waitStatus</span> &gt; 0);
            pred.<span style="color:#007f7f">next</span> = node;
        } <span style="color:#fff;font-weight:bold">else</span> {
            <span style="color:#007f7f">/*
</span><span style="color:#007f7f">             * waitStatus must be 0 or PROPAGATE.  Indicate that we
</span><span style="color:#007f7f">             * need a signal, but don&#39;t park yet.  Caller will need to
</span><span style="color:#007f7f">             * retry to make sure it cannot acquire before parking.
</span><span style="color:#007f7f">             */</span>
            <span style="color:#007f7f">// 仔细想想，如果进入到这个分支意味着什么
</span><span style="color:#007f7f"></span>            <span style="color:#007f7f">// 前驱节点的waitStatus不等于-1和1，那也就是只可能是0，-2，-3
</span><span style="color:#007f7f"></span>            <span style="color:#007f7f">// 在我们前面的源码中，都没有看到有设置waitStatus的，所以每个新的node入队时，waitStatu都是0
</span><span style="color:#007f7f"></span>            <span style="color:#007f7f">// 正常情况下，前驱节点是之前的 tail，那么它的 waitStatus 应该是 0
</span><span style="color:#007f7f"></span>            <span style="color:#007f7f">// 用CAS将前驱节点的waitStatus设置为Node.SIGNAL(也就是-1)
</span><span style="color:#007f7f"></span>            compareAndSetWaitStatus(pred, ws, Node.<span style="color:#007f7f">SIGNAL</span>);
        }
        <span style="color:#007f7f">// 这个方法返回 false，那么会再走一次 for 循序，
</span><span style="color:#007f7f"></span>        <span style="color:#007f7f">//     然后再次进来此方法，此时会从第一个分支返回 true
</span><span style="color:#007f7f"></span>        <span style="color:#fff;font-weight:bold">return</span> <span style="color:#fff;font-weight:bold">false</span>;
    }
  
    <span style="color:#007f7f">// private static boolean shouldParkAfterFailedAcquire(Node pred, Node node)
</span><span style="color:#007f7f"></span>    <span style="color:#007f7f">// 这个方法结束根据返回值我们简单分析下：
</span><span style="color:#007f7f"></span>    <span style="color:#007f7f">// 如果返回true, 说明前驱节点的waitStatus==-1，是正常情况，那么当前线程需要被挂起，等待以后被唤醒
</span><span style="color:#007f7f"></span>    <span style="color:#007f7f">//		我们也说过，以后是被前驱节点唤醒，就等着前驱节点拿到锁，然后释放锁的时候叫你好了
</span><span style="color:#007f7f"></span>    <span style="color:#007f7f">// 如果返回false, 说明当前不需要被挂起，为什么呢？往后看
</span><span style="color:#007f7f"></span>  
    <span style="color:#007f7f">// 跳回到前面是这个方法
</span><span style="color:#007f7f"></span>    <span style="color:#007f7f">// if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;
</span><span style="color:#007f7f"></span>    <span style="color:#007f7f">//                parkAndCheckInterrupt())
</span><span style="color:#007f7f"></span>    <span style="color:#007f7f">//                interrupted = true;
</span><span style="color:#007f7f"></span>    
    <span style="color:#007f7f">// 1. 如果shouldParkAfterFailedAcquire(p, node)返回true，
</span><span style="color:#007f7f"></span>    <span style="color:#007f7f">// 那么需要执行parkAndCheckInterrupt():
</span><span style="color:#007f7f"></span>  
    <span style="color:#007f7f">// 这个方法很简单，因为前面返回true，所以需要挂起线程，这个方法就是负责挂起线程的
</span><span style="color:#007f7f"></span>    <span style="color:#007f7f">// 这里用了LockSupport.park(this)来挂起线程，然后就停在这里了，等待被唤醒=======
</span><span style="color:#007f7f"></span>    <span style="color:#fff;font-weight:bold">private</span> <span style="color:#fff;font-weight:bold">final</span> <span style="color:#fff;font-weight:bold">boolean</span> parkAndCheckInterrupt() {
        LockSupport.<span style="color:#007f7f">park</span>(<span style="color:#fff;font-weight:bold">this</span>);
        <span style="color:#fff;font-weight:bold">return</span> Thread.<span style="color:#007f7f">interrupted</span>();
    }
  
    <span style="color:#007f7f">// 2. 接下来说说如果shouldParkAfterFailedAcquire(p, node)返回false的情况
</span><span style="color:#007f7f"></span>  
   <span style="color:#007f7f">// 仔细看shouldParkAfterFailedAcquire(p, node)，我们可以发现，其实第一次进来的时候，一般都不会返回true的，原因很简单，前驱节点的waitStatus=-1是依赖于后继节点设置的。也就是说，我都还没给前驱设置-1呢，怎么可能是true呢，但是要看到，这个方法是套在循环里的，所以第二次进来的时候状态就是-1了。
</span><span style="color:#007f7f"></span>  
    <span style="color:#007f7f">// 解释下为什么shouldParkAfterFailedAcquire(p, node)返回false的时候不直接挂起线程：
</span><span style="color:#007f7f"></span>    <span style="color:#007f7f">// =&gt; 是为了应对在经过这个方法后，node已经是head的直接后继节点了。剩下的读者自己想想吧。
</span><span style="color:#007f7f"></span>}
</code></pre></div><p>说到这里，也就明白了，多看几遍 <code>final boolean acquireQueued(final Node node, int arg)</code> 这个方法吧。自己推演下各个分支怎么走，哪种情况下会发生什么，走到哪里。</p>
<h2 id="解锁操作">解锁操作</h2>
<p>最后，就是还需要介绍下唤醒的动作了。我们知道，正常情况下，如果线程没获取到锁，线程会被 <code>LockSupport.park(this);</code> 挂起停止，等待被唤醒。</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#007f7f">// 唤醒的代码还是比较简单的，你如果上面加锁的都看懂了，下面都不需要看就知道怎么回事了
</span><span style="color:#007f7f"></span><span style="color:#fff;font-weight:bold">public</span> <span style="color:#fff;font-weight:bold">void</span> unlock() {
    sync.<span style="color:#007f7f">release</span>(1);
}

<span style="color:#fff;font-weight:bold">public</span> <span style="color:#fff;font-weight:bold">final</span> <span style="color:#fff;font-weight:bold">boolean</span> release(<span style="color:#fff;font-weight:bold">int</span> arg) {
    <span style="color:#007f7f">// 往后看吧
</span><span style="color:#007f7f"></span>    <span style="color:#fff;font-weight:bold">if</span> (tryRelease(arg)) {
        Node h = head;
        <span style="color:#fff;font-weight:bold">if</span> (h != <span style="color:#fff;font-weight:bold">null</span> &amp;&amp; h.<span style="color:#007f7f">waitStatus</span> != 0)
            unparkSuccessor(h);
        <span style="color:#fff;font-weight:bold">return</span> <span style="color:#fff;font-weight:bold">true</span>;
    }
    <span style="color:#fff;font-weight:bold">return</span> <span style="color:#fff;font-weight:bold">false</span>;
}

<span style="color:#007f7f">// 回到ReentrantLock看tryRelease方法
</span><span style="color:#007f7f"></span><span style="color:#fff;font-weight:bold">protected</span> <span style="color:#fff;font-weight:bold">final</span> <span style="color:#fff;font-weight:bold">boolean</span> tryRelease(<span style="color:#fff;font-weight:bold">int</span> releases) {
    <span style="color:#fff;font-weight:bold">int</span> c = getState() - releases;
    <span style="color:#fff;font-weight:bold">if</span> (Thread.<span style="color:#007f7f">currentThread</span>() != getExclusiveOwnerThread())
        <span style="color:#fff;font-weight:bold">throw</span> <span style="color:#fff;font-weight:bold">new</span> IllegalMonitorStateException();
    <span style="color:#007f7f">// 是否完全释放锁
</span><span style="color:#007f7f"></span>    <span style="color:#fff;font-weight:bold">boolean</span> free = <span style="color:#fff;font-weight:bold">false</span>;
    <span style="color:#007f7f">// 其实就是重入的问题，如果c==0，也就是说没有嵌套锁了，可以释放了，否则还不能释放掉
</span><span style="color:#007f7f"></span>    <span style="color:#fff;font-weight:bold">if</span> (c == 0) {
        free = <span style="color:#fff;font-weight:bold">true</span>;
        setExclusiveOwnerThread(<span style="color:#fff;font-weight:bold">null</span>);
    }
    setState(c);
    <span style="color:#fff;font-weight:bold">return</span> free;
}

<span style="color:#007f7f">/**
</span><span style="color:#007f7f"> * Wakes up node&#39;s successor, if one exists.
</span><span style="color:#007f7f"> *
</span><span style="color:#007f7f"> * @param node the node
</span><span style="color:#007f7f"> */</span>
<span style="color:#007f7f">// 唤醒后继节点
</span><span style="color:#007f7f">// 从上面调用处知道，参数node是head头结点
</span><span style="color:#007f7f"></span><span style="color:#fff;font-weight:bold">private</span> <span style="color:#fff;font-weight:bold">void</span> unparkSuccessor(Node node) {
    <span style="color:#007f7f">/*
</span><span style="color:#007f7f">     * If status is negative (i.e., possibly needing signal) try
</span><span style="color:#007f7f">     * to clear in anticipation of signalling.  It is OK if this
</span><span style="color:#007f7f">     * fails or if status is changed by waiting thread.
</span><span style="color:#007f7f">     */</span>
    <span style="color:#fff;font-weight:bold">int</span> ws = node.<span style="color:#007f7f">waitStatus</span>;
    <span style="color:#007f7f">// 如果head节点当前waitStatus&lt;0, 将其修改为0
</span><span style="color:#007f7f"></span>    <span style="color:#fff;font-weight:bold">if</span> (ws &lt; 0)
        compareAndSetWaitStatus(node, ws, 0);
    <span style="color:#007f7f">/*
</span><span style="color:#007f7f">     * Thread to unpark is held in successor, which is normally
</span><span style="color:#007f7f">     * just the next node.  But if cancelled or apparently null,
</span><span style="color:#007f7f">     * traverse backwards from tail to find the actual
</span><span style="color:#007f7f">     * non-cancelled successor.
</span><span style="color:#007f7f">     */</span>
    <span style="color:#007f7f">// 下面的代码就是唤醒后继节点，但是有可能后继节点取消了等待（waitStatus==1）
</span><span style="color:#007f7f"></span>    <span style="color:#007f7f">// 从队尾往前找，找到waitStatus&lt;=0的所有节点中排在最前面的
</span><span style="color:#007f7f"></span>    Node s = node.<span style="color:#007f7f">next</span>;
    <span style="color:#fff;font-weight:bold">if</span> (s == <span style="color:#fff;font-weight:bold">null</span> || s.<span style="color:#007f7f">waitStatus</span> &gt; 0) {
        s = <span style="color:#fff;font-weight:bold">null</span>;
        <span style="color:#007f7f">// 从后往前找，仔细看代码，不必担心中间有节点取消(waitStatus==1)的情况
</span><span style="color:#007f7f"></span>        <span style="color:#fff;font-weight:bold">for</span> (Node t = tail; t != <span style="color:#fff;font-weight:bold">null</span> &amp;&amp; t != node; t = t.<span style="color:#007f7f">prev</span>)
            <span style="color:#fff;font-weight:bold">if</span> (t.<span style="color:#007f7f">waitStatus</span> &lt;= 0)
                s = t;
    }
    <span style="color:#fff;font-weight:bold">if</span> (s != <span style="color:#fff;font-weight:bold">null</span>)
        <span style="color:#007f7f">// 唤醒线程
</span><span style="color:#007f7f"></span>        LockSupport.<span style="color:#007f7f">unpark</span>(s.<span style="color:#007f7f">thread</span>);
}
</code></pre></div><p>唤醒线程以后，被唤醒的线程将从以下代码中继续往前走：</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#fff;font-weight:bold">private</span> <span style="color:#fff;font-weight:bold">final</span> <span style="color:#fff;font-weight:bold">boolean</span> parkAndCheckInterrupt() {
    LockSupport.<span style="color:#007f7f">park</span>(<span style="color:#fff;font-weight:bold">this</span>); <span style="color:#007f7f">// 刚刚线程被挂起在这里了
</span><span style="color:#007f7f"></span>    <span style="color:#fff;font-weight:bold">return</span> Thread.<span style="color:#007f7f">interrupted</span>();
}
<span style="color:#007f7f">// 又回到这个方法了：acquireQueued(final Node node, int arg)，这个时候，node的前驱是head了
</span></code></pre></div><p>好了，后面就不分析源码了，剩下的还有问题自己去仔细看看代码吧。</p>
<h2 id="总结">总结</h2>
<p>总结一下吧。</p>
<p>在并发环境下，加锁和解锁需要以下三个部件的协调：</p>
<ol>
<li>锁状态。我们要知道锁是不是被别的线程占有了，这个就是 state 的作用，它为 0 的时候代表没有线程占有锁，可以去争抢这个锁，用 CAS 将 state 设为 1，如果 CAS 成功，说明抢到了锁，这样其他线程就抢不到了，如果锁重入的话，state进行 +1 就可以，解锁就是减 1，直到 state 又变为 0，代表释放锁，所以 lock() 和 unlock() 必须要配对啊。然后唤醒等待队列中的第一个线程，让其来占有锁。</li>
<li>线程的阻塞和解除阻塞。AQS 中采用了 LockSupport.park(thread) 来挂起线程，用 unpark 来唤醒线程。</li>
<li>阻塞队列。因为争抢锁的线程可能很多，但是只能有一个线程拿到锁，其他的线程都必须等待，这个时候就需要一个 queue 来管理这些线程，AQS 用的是一个 FIFO 的队列，就是一个链表，每个 node 都持有后继节点的引用。AQS 采用了 CLH 锁的变体来实现，感兴趣的读者可以参考这篇文章<a href="http://coderbee.net/index.php/concurrent/20131115/577">关于CLH的介绍</a>，写得简单明了。</li>
</ol>
<h2 id="示例图解析">示例图解析</h2>
<p>下面属于回顾环节，用简单的示例来说一遍，如果上面的有些东西没看懂，这里还有一次帮助你理解的机会。</p>
<p>首先，第一个线程调用 reentrantLock.lock()，翻到最前面可以发现，tryAcquire(1) 直接就返回 true 了，结束。只是设置了 state=1，连 head 都没有初始化，更谈不上什么阻塞队列了。要是线程 1 调用 unlock() 了，才有线程 2 来，那世界就太太太平了，完全没有交集嘛，那我还要 AQS 干嘛。</p>
<p>如果线程 1 没有调用 unlock() 之前，线程 2 调用了 lock(), 想想会发生什么？</p>
<p>线程 2 会初始化 head【new Node()】，同时线程 2 也会插入到阻塞队列并挂起 (注意看这里是一个 for 循环，而且设置 head 和 tail 的部分是不 return 的，只有入队成功才会跳出循环)</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#fff;font-weight:bold">private</span> Node enq(<span style="color:#fff;font-weight:bold">final</span> Node node) {
    <span style="color:#fff;font-weight:bold">for</span> (;;) {
        Node t = tail;
        <span style="color:#fff;font-weight:bold">if</span> (t == <span style="color:#fff;font-weight:bold">null</span>) { <span style="color:#007f7f">// Must initialize
</span><span style="color:#007f7f"></span>            <span style="color:#fff;font-weight:bold">if</span> (compareAndSetHead(<span style="color:#fff;font-weight:bold">new</span> Node()))
                tail = head;
        } <span style="color:#fff;font-weight:bold">else</span> {
            node.<span style="color:#007f7f">prev</span> = t;
            <span style="color:#fff;font-weight:bold">if</span> (compareAndSetTail(t, node)) {
                t.<span style="color:#007f7f">next</span> = node;
                <span style="color:#fff;font-weight:bold">return</span> t;
            }
        }
    }
}
</code></pre></div><p>首先，是线程 2 初始化 head 节点，此时 head==tail, waitStatus==0</p>
<p><img src="http://img.zhouyi.tech/note/aqs-1-d16e6bd0da0449539cd714cba5758148.png" alt="aqs-1"></p>
<p>然后线程 2 入队：</p>
<p><img src="http://img.zhouyi.tech/note/aqs-2-e0feb016f5f149449ace3e256515e8ab.png" alt="aqs-2"></p>
<p>同时我们也要看此时节点的 waitStatus，我们知道 head 节点是线程 2 初始化的，此时的 waitStatus 没有设置， java 默认会设置为 0，但是到 shouldParkAfterFailedAcquire 这个方法的时候，线程 2 会把前驱节点，也就是 head 的waitStatus设置为 -1。</p>
<p>那线程 2 节点此时的 waitStatus 是多少呢，由于没有设置，所以是 0；</p>
<p>如果线程 3 此时再进来，直接插到线程 2 的后面就可以了，此时线程 3 的 waitStatus 是 0，到 shouldParkAfterFailedAcquire 方法的时候把前驱节点线程 2 的 waitStatus 设置为 -1。</p>
<p><img src="http://img.zhouyi.tech/note/aqs-3-1972890b222149a190688c4b6e454dad.png" alt="aqs-3"></p>
<p>这里可以简单说下 waitStatus 中 SIGNAL(-1) 状态的意思，Doug Lea 注释的是：代表后继节点需要被唤醒。也就是说这个 waitStatus 其实代表的不是自己的状态，而是后继节点的状态，我们知道，每个 node 在入队的时候，都会把前驱节点的状态改为 SIGNAL，然后阻塞，等待被前驱唤醒。这里涉及的是两个问题：有线程取消了排队、唤醒操作。其实本质是一样的，读者也可以顺着 “waitStatus代表后继节点的状态” 这种思路去看一遍源码。</p>
<p>（全文完）</p>
<p><strong>著作权归原作者所有，<a href="https://javadoop.com/post/AbstractQueuedSynchronizer">原文链接</a>。</strong></p>
  </article>
</section>


</main>

You must set a googleAnalytics UA-Code within the global config.toml Params.

</body>

</html>

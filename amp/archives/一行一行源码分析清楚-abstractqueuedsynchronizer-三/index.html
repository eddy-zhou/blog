<!DOCTYPE html>




<html amp lang="zh-cn" class="no-js">
<head>
  <title>一行一行源码分析清楚 AbstractQueuedSynchronizer (三)</title>
  <meta charset="utf-8">

  <script async custom-element="amp-ad" src="https://cdn.ampproject.org/v0/amp-ad-0.1.js"></script><script async custom-element="amp-analytics" src="https://cdn.ampproject.org/v0/amp-analytics-0.1.js"></script>

    <script async src="https://cdn.ampproject.org/v0.js"></script>

    




  <link rel="canonical" href="https://www.zhouyi.tech/archives/%E4%B8%80%E8%A1%8C%E4%B8%80%E8%A1%8C%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E6%B8%85%E6%A5%9A-abstractqueuedsynchronizer-%E4%B8%89/">

  <link rel="icon" href="https://www.zhouyi.tech/favicon.png" type="image/png" sizes="144x144">

  <meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1">

  <meta name="theme-color" content="#000000" />

  
<script type="application/ld+json">
{
    "@context": "http://schema.org",
    "@type": "WebSite",
    "name": "程序员学习之路",
    
    "url": "https:\/\/www.zhouyi.tech"
}
</script>
<script type="application/ld+json">
{
  "@context": "http://schema.org",
  "@type": "Organization",
  "name": "",
  "url": "https:\/\/www.zhouyi.tech"
  
  
  
  
}
</script>
































<script type="application/ld+json">
{
  "@context": "http://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [{
        "@type": "ListItem",
        "position":  1 ,
        "item": {
          "@id": "https:\/\/www.zhouyi.tech",
          "name": "home"
        }
    },{
        "@type": "ListItem",
        "position":  3 ,
        "item": {
          "@id": "https:\/\/www.zhouyi.tech\/amp\/",
          "name": "amp"
        }
    },{
        "@type": "ListItem",
        "position":  4 ,
        "item": {
          "@id": "https:\/\/www.zhouyi.tech\/amp\/archives\/",
          "name": "archives"
        }
    },{
        "@type": "ListItem",
        "position":  5 ,
        "item": {
          "@id": "https:\/\/www.zhouyi.tech\/amp\/archives\/%E4%B8%80%E8%A1%8C%E4%B8%80%E8%A1%8C%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E6%B8%85%E6%A5%9A-abstractqueuedsynchronizer-%E4%B8%89\/",
          "name": "%E4%B8%80%E8%A1%8C%E4%B8%80%E8%A1%8C%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E6%B8%85%E6%A5%9A-abstractqueuedsynchronizer-%E4%B8%89"
        }
    }]
}
</script>





    <style amp-boilerplate>body{-webkit-animation:-amp-start 8s steps(1,end) 0s 1 normal both;-moz-animation:-amp-start 8s steps(1,end) 0s 1 normal both;-ms-animation:-amp-start 8s steps(1,end) 0s 1 normal both;animation:-amp-start 8s steps(1,end) 0s 1 normal both}@-webkit-keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}@-moz-keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}@-ms-keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}@-o-keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}@keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}</style><noscript><style amp-boilerplate>body{-webkit-animation:none;-moz-animation:none;-ms-animation:none;animation:none}</style></noscript>
    <style amp-custom>
        /**
* stylesheet.html
* ---------------
* This is the stylesheet that gets injected as a fallback if no layouts/partials/stylesheet.html file is available
* in your project file.
*
* For further details, please have a look at:
* https://gohugo-amp.gohugohq.com/install/
*
**/
html{font-family:sans-serif;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}body{margin:0}article,aside,details,figcaption,figure,footer,header,hgroup,main,nav,section,summary{display:block}audio,canvas,progress,video{display:inline-block;vertical-align:baseline}audio:not([controls]){display:none;height:0}[hidden],template{display:none}a{background:transparent}a:active,a:hover{outline:0}abbr[title]{border-bottom:1px
dotted}b,strong{font-weight:700}dfn{font-style:italic}h1{font-size:2em;margin:.67em
0}mark{background:#ff0;color:#000}small{font-size:80%}sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}sup{top:-.5em}sub{bottom:-.25em}img{border:0}svg:not(:root){overflow:hidden}figure{margin:1em
40px}hr{box-sizing:content-box;height:0}pre{overflow:auto}code,kbd,pre,samp{font-family:monospace,monospace;font-size:1em}button,input,optgroup,select,textarea{color:inherit;font:inherit;margin:0}button{overflow:visible}button,select{text-transform:none}button,html
input[type=button],input[type=reset],input[type=submit]{-webkit-appearance:button;cursor:pointer}button[disabled],html
input[disabled]{cursor:default}button::-moz-focus-inner,input::-moz-focus-inner{border:0;padding:0}input{line-height:normal}input[type=checkbox],input[type=radio]{box-sizing:border-box;padding:0}input[type=number]::-webkit-inner-spin-button,input[type=number]::-webkit-outer-spin-button{height:auto}input[type=search]{-webkit-appearance:textfield;box-sizing:content-box}input[type=search]::-webkit-search-cancel-button,input[type=search]::-webkit-search-decoration{-webkit-appearance:none}fieldset{border:1px
solid silver;margin:0 2px;padding:.35em .625em
.75em}legend{border:0;padding:0}textarea{overflow:auto}optgroup{font-weight:700}td,th{padding:0}*{box-sizing:border-box}button,input,select,textarea{font:13px/1.4
Helvetica,arial,freesans,clean,sans-serif}a{color:#4183c4;text-decoration:none}a:active,a:focus,a:hover{text-decoration:underline}.rule,hr{height:0;margin:15px
0;overflow:hidden;background:transparent;border:0;border-bottom:1px solid
#ddd}.rule:after,.rule:before,hr:after,hr:before{display:table;content:""}.rule:after,hr:after{clear:both}fieldset{padding:0;margin:0;border:0}label{font-size:13px;font-weight:700}#adv_code_search
.search-page-label,input[type=email],input[type=number],input[type=password],input[type=tel],input[type=text],input[type=url],textarea{min-height:34px;padding:7px
8px;font-size:13px;color:#333;vertical-align:middle;background-color:#fff;background-repeat:no-repeat;background-position:100%;border:1px
solid #ccc;border-radius:3px;outline:none;box-shadow:inset 0 1px 2px rgba(0,0,0,.075)}#adv_code_search
.focus.search-page-label,#adv_code_search .search-page-label:focus,.focused
.drag-and-drop,input[type=email].focus,input[type=email]:focus,input[type=number].focus,input[type=number]:focus,input[type=password].focus,input[type=password]:focus,input[type=tel].focus,input[type=tel]:focus,input[type=text].focus,input[type=text]:focus,input[type=url].focus,input[type=url]:focus,textarea.focus,textarea:focus{border-color:#51a7e8;box-shadow:inset
0 1px 2px rgba(0,0,0,.075),0 0 5px
rgba(81,167,232,.5)}.input-contrast,input.input-contrast{background-color:#fafafa}.input-contrast:focus,input.input-contrast:focus{background-color:#fff}:-moz-placeholder,::-webkit-input-placeholder{color:#aaa}::-webkit-validation-bubble-message{font-size:12px;color:#fff;background:#9c2400;border:0;border-radius:3px;-webkit-box-shadow:1px
1px 1px
rgba(0,0,0,.1)}input::-webkit-validation-bubble-icon{display:none}::-webkit-validation-bubble-arrow{background-color:#9c2400;border:1px
solid #9c2400;-webkit-box-shadow:1px 1px 1px
rgba(0,0,0,.1)}.absent{color:#c00}.anchor{position:absolute;top:0;bottom:0;left:0;display:block;padding-right:6px;padding-left:30px;margin-left:-30px}.anchor:focus{outline:none}h1,h2,h3,h4,h5,h6{position:relative;margin-top:1em;margin-bottom:16px;font-weight:700;line-height:1.4}h1
.octicon-link,h2 .octicon-link,h3 .octicon-link,h4 .octicon-link,h5 .octicon-link,h6
.octicon-link{display:none;color:#000;vertical-align:middle}h1:hover .anchor,h2:hover .anchor,h3:hover .anchor,h4:hover
.anchor,h5:hover .anchor,h6:hover
.anchor{height:1em;padding-left:8px;margin-left:-30px;line-height:1;text-decoration:none}h1:hover .anchor
.octicon-link,h2:hover .anchor .octicon-link,h3:hover .anchor .octicon-link,h4:hover .anchor .octicon-link,h5:hover
.anchor .octicon-link,h6:hover .anchor .octicon-link{display:inline-block}h1 code,h1 tt,h2 code,h2 tt,h3 code,h3 tt,h4
code,h4 tt,h5 code,h5 tt,h6 code,h6
tt{font-size:inherit}h1{font-size:2.25em;line-height:1.2}h1,h2{padding-bottom:.3em;border-bottom:1px solid
#eee}h2{font-size:1.75em;line-height:1.225}h3{font-size:1.5em;line-height:1.43}h4{font-size:1.25em}h5,h6{font-size:1em}h6{color:#777}blockquote,dl,ol,p,pre,table,ul{margin-top:0;margin-bottom:16px}hr{height:4px;padding:0;margin:16px
0;background-color:#e7e7e7;border:0 none}ol,ul{padding-left:2em}ol.no-list,ul.no-list{padding:0;list-style-type:none}ol
ol,ol ul,ul ol,ul ul{margin-top:0;margin-bottom:0}li>p{margin-top:16px}dl,dl dt{padding:0}dl
dt{margin-top:16px;font-size:1em;font-style:italic;font-weight:700}dl dd{padding:0
16px;margin-bottom:16px}blockquote{padding:0 15px;color:#777;border-left:4px solid
#ddd}blockquote>:first-child{margin-top:0}blockquote>:last-child{margin-bottom:0}table{display:block;width:100%;overflow:auto;word-break:normal;word-break:keep-all}table
th{font-weight:700}table td,table th{padding:6px 13px;border:1px solid #ddd}table
tr{background-color:#fff;border-top:1px solid #ccc}table
tr:nth-child(2n){background-color:#f8f8f8}img{max-width:100%;box-sizing:border-box}span.frame,span.frame>span{display:block;overflow:hidden}span.frame>span{float:left;width:auto;padding:7px;margin:13px
0 0;border:1px solid #ddd}span.frame span img{display:block;float:left}span.frame span span{display:block;padding:5px 0
0;clear:both;color:#333}span.align-center{display:block;overflow:hidden;clear:both}span.align-center>span{display:block;margin:13px
auto 0;overflow:hidden;text-align:center}span.align-center span img{margin:0
auto;text-align:center}span.align-right{display:block;overflow:hidden;clear:both}span.align-right>span{display:block;margin:13px
0 0;overflow:hidden;text-align:right}span.align-right span
img{margin:0;text-align:right}span.float-left{display:block;float:left;margin-right:13px;overflow:hidden}span.float-left
span{margin:13px 0
0}span.float-right{display:block;float:right;margin-left:13px;overflow:hidden}span.float-right>span{display:block;margin:13px
auto
0;overflow:hidden;text-align:right}code,tt{padding:0;padding-top:.2em;padding-bottom:.2em;margin:0;font-size:85%;background-color:rgba(0,0,0,.04);border-radius:3px}code:after,code:before,tt:after,tt:before{letter-spacing:-.2em;content:"\00a0"}code
br,tt br{display:none}del
code{text-decoration:inherit;vertical-align:text-top}pre>code{padding:0;margin:0;font-size:100%;word-break:normal;white-space:pre;background:transparent;border:0}.highlight{margin-bottom:16px}.highlight
pre,pre{padding:16px;overflow:auto;font-size:85%;line-height:1.45;background-color:#f7f7f7;border-radius:3px}.highlight
pre{margin-bottom:0;word-break:normal}pre,pre code,pre tt{word-wrap:normal}pre code,pre
tt{display:inline;max-width:none;padding:0;margin:0;overflow:initial;line-height:inherit;background-color:transparent;border:0}pre
code:after,pre code:before,pre tt:after,pre
tt:before{content:normal}abbr,address,article,aside,audio,b,blockquote,body,canvas,caption,cite,code,dd,del,details,dfn,div,dl,dt,em,fieldset,figcaption,figure,footer,form,h1,h2,h3,h4,h5,h6,header,hgroup,html,i,iframe,img,ins,kbd,label,legend,li,mark,menu,nav,object,ol,p,pre,q,samp,section,small,span,strong,sub,summary,sup,table,tbody,td,tfoot,th,thead,time,tr,ul,var,video{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}article,aside,details,figcaption,figure,footer,header,hgroup,menu,nav,section{display:block}nav
ul{list-style:none}blockquote,q{quotes:none}blockquote:after,blockquote:before,q:after,q:before{content:'';content:none}a{margin:0;padding:0;font-size:100%;vertical-align:baseline;background:transparent}ins{text-decoration:none}ins,mark{background-color:#ff9;color:#000}mark{font-style:italic;font-weight:700}del{text-decoration:line-through}abbr[title],dfn[title]{border-bottom:1px
dotted;cursor:help}table{border-collapse:collapse;border-spacing:0}hr{display:block;height:1px;border:0;border-top:1px
solid #ccc;margin:1em
0;padding:0}input,select{vertical-align:middle}body{background-color:#fff;color:#123;font-size:14px;font-family:Helvetica
Neue,Helvetica,Segoe UI,Arial,freesans,sans-serif}main{max-width:1180px;padding:30px;margin:0 auto}@media
(min-width:900px){main h1+p{font-size:2em}}h1{font-weight:300;font-size:2em;line-height:1.4em;margin:.5em
0;font-family:Georgia,serif;-webkit-transition:color .4s;transition:color
.4s}h2{font-size:2em}h2,h3{font-weight:300;margin:30px
0}h3{font-size:1.8em}h4{font-size:1.6em}h4,h5{font-weight:300}h5{font-size:1.2em}h6{font-weight:300;font-size:1em}p{line-height:1.4em;font-size:1.2em;margin:15px
0}blockquote{border-left:5px solid
#ff1d55;background-color:#ffe9ee;padding:1em;margin-bottom:1em}.lightbox{background-color:rgba(3,121,196,.4);min-height:100vh;min-width:100vw;padding:30px}code{font:12px
Consolas,Liberation Mono,Menlo,Courier,monospace}p>code{color:#ff1d55}pre
code{display:block;background-color:#f7f7f7;padding:15px;overflow:auto;color:#123;line-height:1.4em}a{color:#ff1d55;text-decoration:none;-webkit-transition:color
.4s,background .4s;transition:color .4s,background .4s}a:hover{color:#e9003a}ol,ul{margin:7.5px;padding:7.5px 15px}ol
li,ul li{margin:7.5px 15px}.doc-parameters{list-style-type:none;padding:0}.doc-parameters
li{display:block;margin:0;margin-bottom:15px}.doc-parameters .example,.doc-parameters blockquote{border-left:5px solid
#0379c4;background-color:#96d5fd;color:#123;line-height:1em;font-size:1em;padding:1em;margin:0}.doc-parameters
.example{background-color:#c8e9fe}.doc-parameters
.parameter{display:block;padding:1em;background-color:#0379c4;color:#fff;margin:0}.doc-parameters .parameter
strong{display:inline-block;padding:0
.5em;border-radius:.25em;line-height:2em;background-color:#025a92}hr{height:.25em;padding:0;margin:24px
0;background-color:#f7f7f7;border:0}.teaser{display:-webkit-box;display:-ms-flexbox;display:flex;text-align:left;-ms-flex-line-pack:center;align-content:center;-ms-flex-wrap:wrap;flex-wrap:wrap;-webkit-box-pack:justify;-ms-flex-pack:justify;justify-content:space-between}.teaser
aside{-ms-flex-preferred-size:60%;flex-basis:60%;-ms-flex-item-align:center;-ms-grid-row-align:center;align-self:center;padding:30px}@media
(max-width:700px){.teaser aside{-ms-flex-preferred-size:100%;flex-basis:100%}}.teaser
.content{-ms-flex-preferred-size:40%;flex-basis:40%;-ms-flex-item-align:center;-ms-grid-row-align:center;align-self:center;color:dimgray;font-size:12px}@media
(max-width:700px){.teaser .content{-ms-flex-preferred-size:100%;flex-basis:100%}}.teaser
.content.content-full{-ms-flex-preferred-size:100%;flex-basis:100%}.teaser .content
h3{font-size:14px;text-transform:uppercase;font-weight:600;color:#123}.main-index{text-align:center}.main-index
amp-img{margin:15px auto;width:50%}@media (min-width:900px){.main-index
p{font-size:2em}}.breadcrumbs{padding:1em;background-color:#f7f7f7}.breadcrumbs
ul{display:block;margin:0;padding:0}.breadcrumbs ul li{display:inline-block;margin:0 .5em}.breadcrumbs ul
li:before{content:' / ';position:relative;margin-left:-.5em;color:dimgray}.breadcrumbs ul li
a{color:dimgray}.breadcrumbs ul li:last-child
a{color:#ff1d55}header{background-color:#000000;color:#fff;padding:30px;position:relative}header
.brand{display:inline-block;position:absolute;left:30px;top:20px;line-height:15px;text-transform:uppercase;padding:7.5px;font-size:1.4em}header
.brand:hover{background-color:#ff1d55;color:#fff}header
a{color:#fff;text-decoration:none;border-radius:7.5px;padding:7.5px}header
a:hover{text-decoration:none;background-color:#fff;color:#ff1d55}header nav
ul{padding:0;margin:0;display:block;text-align:right}header nav ul li{padding:0;margin:0
7.5px;display:inline-block}header nav ul li.hamburger{display:none}header nav ul li.hamburger
button{position:absolute;right:30px;top:20px;border:0;background-color:#fff;color:#ff1d55;font-weight:700;border-radius:50%;width:30px;height:30px;overflow:hidden;text-align:center;padding:0;margin:0}@media
(max-width:900px){header nav ul li{display:none}header nav ul
li.hamburger{display:inline-block}}.sidebarNavigation{width:210px;max-width:95%}.sidebarNavigation
ul{padding:0;margin:0}.sidebarNavigation ul li{display:block}.sidebarNavigation ul li
a{display:block;line-height:1.4em;padding:7.5px}footer{margin:60px
auto;display:-webkit-box;display:-ms-flexbox;display:flex;-ms-flex-line-pack:center;align-content:center;-ms-flex-wrap:wrap;flex-wrap:wrap;-webkit-box-pack:justify;-ms-flex-pack:justify;justify-content:space-between;max-width:1180px;padding:30px;font-size:12px}footer
a:hover{text-decoration:none}footer strong{text-transform:uppercase;margin-bottom:15px;display:block}footer strong
a{color:#1d1d1d}footer ul{display:block;padding:0;margin:0}footer ul li{display:block;line-height:1.4em;padding:7.5px
0;margin:0}footer ul li a{color:dimgray}footer
.quarter-section{margin-bottom:30px;-ms-flex-preferred-size:25%;flex-basis:25%}@media (max-width:900px){footer
.quarter-section{-ms-flex-preferred-size:33%;flex-basis:33%}}@media (max-width:700px){footer
.quarter-section{-ms-flex-preferred-size:50%;flex-basis:50%}}@media (max-width:500px){footer
.quarter-section{-ms-flex-preferred-size:100%;flex-basis:100%}}.boxes{display:-webkit-box;display:-ms-flexbox;display:flex;-ms-flex-line-pack:center;align-content:center;-ms-flex-wrap:wrap;flex-wrap:wrap;-webkit-box-pack:justify;-ms-flex-pack:justify;justify-content:space-between;font-size:12px}.boxes
.box{-ms-flex-preferred-size:30%;flex-basis:30%;background-color:#f7f7f7;padding:30px;margin:7.5px
0;text-align:left;font-size:12px}.boxes .box h3{font-size:12px;line-height:1em;padding:0;margin:0}.boxes .box
a{padding:0;color:#ff1d55}.boxes .box p{color:dimgray;font-size:12px;margin:7.5px 0}@media (max-width:900px){.boxes
.box{-ms-flex-preferred-size:45%;flex-basis:45%}}@media (max-width:500px){.boxes
.box{-ms-flex-preferred-size:100%;flex-basis:100%}}

.fixed-container {
  position: relative;
  width: 100%;
  height: 300px;
  margin: auto;
}

amp-img.contain img {
  object-fit: contain;
}

.footnotes {
  overflow-wrap: break-word;
}

    </style>


</head>

<body>

<main>
  
  <section class="container page">
  <article>
    <header>
      <h1>一行一行源码分析清楚 AbstractQueuedSynchronizer (三)</h1>
    </header>

    <p>这篇文章是 AQS 系列的最后一篇，第一篇，我们通过 ReentrantLock 公平锁分析了 AQS 的核心，第二篇的重点是把 Condition 说明白，同时也说清楚了对于线程中断的使用。</p>
<p>这篇，我们的关注点是 AQS 最后的部分，<strong>AQS 共享模式</strong>的使用。有前两篇文章的铺垫，剩下的源码分析将会简单很多。</p>
<p>本文先用 CountDownLatch 将共享模式说清楚，然后顺着把其他 AQS 相关的类 CyclicBarrier、Semaphore 的源码一起过一下。</p>
<p>相对来说，如果读者有前面两篇文章的基础，这篇文章是简单很多，不过对于初学者来说，1 小时估计也是免不了的。</p>
<!-- more -->
<!-- toc -->
<h2 id="countdownlatch">CountDownLatch</h2>
<p>CountDownLatch 这个类是比较典型的 AQS 的共享模式的使用，这是一个高频使用的类。latch 的中文意思是<strong>门栓、栅栏</strong>，具体怎么解释我就不废话了，大家随意，看两个例子就知道在哪里用、怎么用了。</p>
<h3 id="使用例子">使用例子</h3>
<p>我们看下 Doug Lea 在 java doc 中给出的例子，这个例子非常实用，我经常会写到这个代码。</p>
<p>假设我们有 N ( N &gt; 0 ) 个任务，那么我们会用 N 来初始化一个 CountDownLatch，然后将这个 latch 的引用传递到各个线程中，在每个线程完成了任务后，调用 latch.countDown() 代表完成了一个任务。</p>
<p>调用 latch.await() 的方法的线程会阻塞，直到所有的任务完成。</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#fff;font-weight:bold">class</span> Driver2 { <span style="color:#007f7f">// ...
</span><span style="color:#007f7f"></span>    <span style="color:#fff;font-weight:bold">void</span> main() <span style="color:#fff;font-weight:bold">throws</span> InterruptedException {
        CountDownLatch doneSignal = <span style="color:#fff;font-weight:bold">new</span> CountDownLatch(N);
        Executor e = Executors.<span style="color:#007f7f">newFixedThreadPool</span>(8);

        <span style="color:#007f7f">// 创建 N 个任务，提交给线程池来执行
</span><span style="color:#007f7f"></span>        <span style="color:#fff;font-weight:bold">for</span> (<span style="color:#fff;font-weight:bold">int</span> i = 0; i &lt; N; ++i) <span style="color:#007f7f">// create and start threads
</span><span style="color:#007f7f"></span>            e.<span style="color:#007f7f">execute</span>(<span style="color:#fff;font-weight:bold">new</span> WorkerRunnable(doneSignal, i));

        <span style="color:#007f7f">// 等待所有的任务完成，这个方法才会返回
</span><span style="color:#007f7f"></span>        doneSignal.<span style="color:#007f7f">await</span>();           <span style="color:#007f7f">// wait for all to finish
</span><span style="color:#007f7f"></span>    }
}

<span style="color:#fff;font-weight:bold">class</span> WorkerRunnable <span style="color:#fff;font-weight:bold">implements</span> Runnable {
    <span style="color:#fff;font-weight:bold">private</span> <span style="color:#fff;font-weight:bold">final</span> CountDownLatch doneSignal;
    <span style="color:#fff;font-weight:bold">private</span> <span style="color:#fff;font-weight:bold">final</span> <span style="color:#fff;font-weight:bold">int</span> i;

    WorkerRunnable(CountDownLatch doneSignal, <span style="color:#fff;font-weight:bold">int</span> i) {
        <span style="color:#fff;font-weight:bold">this</span>.<span style="color:#007f7f">doneSignal</span> = doneSignal;
        <span style="color:#fff;font-weight:bold">this</span>.<span style="color:#007f7f">i</span> = i;
    }

    <span style="color:#fff;font-weight:bold">public</span> <span style="color:#fff;font-weight:bold">void</span> run() {
        <span style="color:#fff;font-weight:bold">try</span> {
            doWork(i);
            <span style="color:#007f7f">// 这个线程的任务完成了，调用 countDown 方法
</span><span style="color:#007f7f"></span>            doneSignal.<span style="color:#007f7f">countDown</span>();
        } <span style="color:#fff;font-weight:bold">catch</span> (InterruptedException ex) {
        } <span style="color:#007f7f">// return;
</span><span style="color:#007f7f"></span>    }

    <span style="color:#fff;font-weight:bold">void</span> doWork() { ...}
}
</code></pre></div><p>所以说 CountDownLatch 非常实用，我们常常会将一个比较大的任务进行拆分，然后开启多个线程来执行，等所有线程都执行完了以后，再往下执行其他操作。这里例子中，<strong>只有 main 线程调用了 await 方法</strong>。</p>
<p>我们再来看另一个例子，这个例子很典型，用了两个 CountDownLatch：</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#fff;font-weight:bold">class</span> Driver { <span style="color:#007f7f">// ...
</span><span style="color:#007f7f"></span>    <span style="color:#fff;font-weight:bold">void</span> main() <span style="color:#fff;font-weight:bold">throws</span> InterruptedException {
        CountDownLatch startSignal = <span style="color:#fff;font-weight:bold">new</span> CountDownLatch(1);
        CountDownLatch doneSignal = <span style="color:#fff;font-weight:bold">new</span> CountDownLatch(N);
 
        <span style="color:#fff;font-weight:bold">for</span> (<span style="color:#fff;font-weight:bold">int</span> i = 0; i &lt; N; ++i) <span style="color:#007f7f">// create and start threads
</span><span style="color:#007f7f"></span>            <span style="color:#fff;font-weight:bold">new</span> Thread(<span style="color:#fff;font-weight:bold">new</span> Worker(startSignal, doneSignal)).<span style="color:#007f7f">start</span>();

        <span style="color:#007f7f">// 这边插入一些代码，确保上面的每个线程先启动起来，才执行下面的代码。
</span><span style="color:#007f7f"></span>        doSomethingElse();            <span style="color:#007f7f">// don&#39;t let run yet
</span><span style="color:#007f7f"></span>        <span style="color:#007f7f">// 因为这里 N == 1，所以，只要调用一次，那么所有的 await 方法都可以通过
</span><span style="color:#007f7f"></span>        startSignal.<span style="color:#007f7f">countDown</span>();      <span style="color:#007f7f">// let all threads proceed
</span><span style="color:#007f7f"></span>        doSomethingElse();
        <span style="color:#007f7f">// 等待所有任务结束
</span><span style="color:#007f7f"></span>        doneSignal.<span style="color:#007f7f">await</span>();           <span style="color:#007f7f">// wait for all to finish
</span><span style="color:#007f7f"></span>    }
}

<span style="color:#fff;font-weight:bold">class</span> Worker <span style="color:#fff;font-weight:bold">implements</span> Runnable {
    <span style="color:#fff;font-weight:bold">private</span> <span style="color:#fff;font-weight:bold">final</span> CountDownLatch startSignal;
    <span style="color:#fff;font-weight:bold">private</span> <span style="color:#fff;font-weight:bold">final</span> CountDownLatch doneSignal;

    Worker(CountDownLatch startSignal, CountDownLatch doneSignal) {
        <span style="color:#fff;font-weight:bold">this</span>.<span style="color:#007f7f">startSignal</span> = startSignal;
        <span style="color:#fff;font-weight:bold">this</span>.<span style="color:#007f7f">doneSignal</span> = doneSignal;
    }

    <span style="color:#fff;font-weight:bold">public</span> <span style="color:#fff;font-weight:bold">void</span> run() {
        <span style="color:#fff;font-weight:bold">try</span> {
            <span style="color:#007f7f">// 为了让所有线程同时开始任务，我们让所有线程先阻塞在这里
</span><span style="color:#007f7f"></span>            <span style="color:#007f7f">// 等大家都准备好了，再打开这个门栓
</span><span style="color:#007f7f"></span>            startSignal.<span style="color:#007f7f">await</span>();
            doWork();
            doneSignal.<span style="color:#007f7f">countDown</span>();
        } <span style="color:#fff;font-weight:bold">catch</span> (InterruptedException ex) {
        } <span style="color:#007f7f">// return;
</span><span style="color:#007f7f"></span>    }

    <span style="color:#fff;font-weight:bold">void</span> doWork() { ...}
}
</code></pre></div><p>这个例子中，doneSignal 同第一个例子的使用，我们说说这里的 startSignal。N 个新开启的线程都调用了startSignal.await() 进行阻塞等待，它们阻塞在<strong>栅栏</strong>上，只有当条件满足的时候（startSignal.countDown()），它们才能同时通过这个栅栏，目的是让所有的线程站在一个起跑线上。</p>
<p><img src="http://img.zhouyi.tech/note/5-f7b3babb83a64f6aae9be7fc28fc6b08.png" alt="5"></p>
<p>如果始终只有一个线程调用 await 方法等待任务完成，那么 CountDownLatch 就会简单很多，所以之后的源码分析读者一定要在脑海中构建出这么一个场景：有 m 个线程是做任务的，有 n 个线程在某个栅栏上等待这 m 个线程做完任务，直到所有 m 个任务完成后，n 个线程同时通过栅栏。</p>
<h3 id="源码分析">源码分析</h3>
<p>Talk is cheap, show me the code.</p>
<p>构造方法，需要传入一个不小于 0 的整数：</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#fff;font-weight:bold">public</span> CountDownLatch(<span style="color:#fff;font-weight:bold">int</span> count) {
    <span style="color:#fff;font-weight:bold">if</span> (count &lt; 0) <span style="color:#fff;font-weight:bold">throw</span> <span style="color:#fff;font-weight:bold">new</span> IllegalArgumentException(<span style="color:#0ff;font-weight:bold">&#34;count &lt; 0&#34;</span>);
    <span style="color:#fff;font-weight:bold">this</span>.<span style="color:#007f7f">sync</span> = <span style="color:#fff;font-weight:bold">new</span> Sync(count);
}
<span style="color:#007f7f">// 老套路了，内部封装一个 Sync 类继承自 AQS
</span><span style="color:#007f7f"></span><span style="color:#fff;font-weight:bold">private</span> <span style="color:#fff;font-weight:bold">static</span> <span style="color:#fff;font-weight:bold">final</span> <span style="color:#fff;font-weight:bold">class</span> Sync <span style="color:#fff;font-weight:bold">extends</span> AbstractQueuedSynchronizer {
    Sync(<span style="color:#fff;font-weight:bold">int</span> count) {
        <span style="color:#007f7f">// 这样就 state == count 了
</span><span style="color:#007f7f"></span>        setState(count);
    }
    ...
}
</code></pre></div><blockquote>
<p>代码都是套路，先分析套路：AQS 里面的 state 是一个整数值，这边用一个 int count 参数其实初始化就是设置了这个值，所有调用了 await 方法的等待线程会挂起，然后有其他一些线程会做 state = state - 1 操作，当 state 减到 0 的同时，那个将 state 减为 0 的线程会负责唤醒 所有调用了 await 方法的线程。都是套路啊，只是 Doug Lea 的套路很深，代码很巧妙，不然我们也没有要分析源码的必要。</p>
</blockquote>
<p>对于 CountDownLatch，我们仅仅需要关心两个方法，一个是 countDown() 方法，另一个是 await() 方法。</p>
<p>countDown() 方法每次调用都会将 state 减 1，直到 state 的值为 0；而 await 是一个阻塞方法，当 state 减为 0 的时候，await 方法才会返回。await 可以被多个线程调用，读者这个时候脑子里要有个图：所有调用了 await 方法的线程阻塞在 AQS 的阻塞队列中，等待条件满足（state == 0），将线程从队列中一个个唤醒过来。</p>
<p>我们用以下程序来分析源码，t1 和 t2 负责调用 countDown() 方法，t3 和 t4 调用 await 方法阻塞：</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#fff;font-weight:bold">public</span> <span style="color:#fff;font-weight:bold">class</span> CountDownLatchDemo {

    <span style="color:#fff;font-weight:bold">public</span> <span style="color:#fff;font-weight:bold">static</span> <span style="color:#fff;font-weight:bold">void</span> main(String[] args) {

        CountDownLatch latch = <span style="color:#fff;font-weight:bold">new</span> CountDownLatch(2);

        Thread t1 = <span style="color:#fff;font-weight:bold">new</span> Thread(<span style="color:#fff;font-weight:bold">new</span> Runnable() {
            @Override
            <span style="color:#fff;font-weight:bold">public</span> <span style="color:#fff;font-weight:bold">void</span> run() {
                <span style="color:#fff;font-weight:bold">try</span> {
                    Thread.<span style="color:#007f7f">sleep</span>(5000);
                } <span style="color:#fff;font-weight:bold">catch</span> (InterruptedException ignore) {
                }
                <span style="color:#007f7f">// 休息 5 秒后(模拟线程工作了 5 秒)，调用 countDown()
</span><span style="color:#007f7f"></span>                latch.<span style="color:#007f7f">countDown</span>();
            }
        }, <span style="color:#0ff;font-weight:bold">&#34;t1&#34;</span>);

        Thread t2 = <span style="color:#fff;font-weight:bold">new</span> Thread(<span style="color:#fff;font-weight:bold">new</span> Runnable() {
            @Override
            <span style="color:#fff;font-weight:bold">public</span> <span style="color:#fff;font-weight:bold">void</span> run() {
                <span style="color:#fff;font-weight:bold">try</span> {
                    Thread.<span style="color:#007f7f">sleep</span>(10000);
                } <span style="color:#fff;font-weight:bold">catch</span> (InterruptedException ignore) {
                }
                <span style="color:#007f7f">// 休息 10 秒后(模拟线程工作了 10 秒)，调用 countDown()
</span><span style="color:#007f7f"></span>                latch.<span style="color:#007f7f">countDown</span>();
            }
        }, <span style="color:#0ff;font-weight:bold">&#34;t2&#34;</span>);

        t1.<span style="color:#007f7f">start</span>();
        t2.<span style="color:#007f7f">start</span>();

        Thread t3 = <span style="color:#fff;font-weight:bold">new</span> Thread(<span style="color:#fff;font-weight:bold">new</span> Runnable() {
            @Override
            <span style="color:#fff;font-weight:bold">public</span> <span style="color:#fff;font-weight:bold">void</span> run() {
                <span style="color:#fff;font-weight:bold">try</span> {
                    <span style="color:#007f7f">// 阻塞，等待 state 减为 0
</span><span style="color:#007f7f"></span>                    latch.<span style="color:#007f7f">await</span>();
                    System.<span style="color:#007f7f">out</span>.<span style="color:#007f7f">println</span>(<span style="color:#0ff;font-weight:bold">&#34;线程 t3 从 await 中返回了&#34;</span>);
                } <span style="color:#fff;font-weight:bold">catch</span> (InterruptedException e) {
                    System.<span style="color:#007f7f">out</span>.<span style="color:#007f7f">println</span>(<span style="color:#0ff;font-weight:bold">&#34;线程 t3 await 被中断&#34;</span>);
                    Thread.<span style="color:#007f7f">currentThread</span>().<span style="color:#007f7f">interrupt</span>();
                }
            }
        }, <span style="color:#0ff;font-weight:bold">&#34;t3&#34;</span>);
        Thread t4 = <span style="color:#fff;font-weight:bold">new</span> Thread(<span style="color:#fff;font-weight:bold">new</span> Runnable() {
            @Override
            <span style="color:#fff;font-weight:bold">public</span> <span style="color:#fff;font-weight:bold">void</span> run() {
                <span style="color:#fff;font-weight:bold">try</span> {
                    <span style="color:#007f7f">// 阻塞，等待 state 减为 0
</span><span style="color:#007f7f"></span>                    latch.<span style="color:#007f7f">await</span>();
                    System.<span style="color:#007f7f">out</span>.<span style="color:#007f7f">println</span>(<span style="color:#0ff;font-weight:bold">&#34;线程 t4 从 await 中返回了&#34;</span>);
                } <span style="color:#fff;font-weight:bold">catch</span> (InterruptedException e) {
                    System.<span style="color:#007f7f">out</span>.<span style="color:#007f7f">println</span>(<span style="color:#0ff;font-weight:bold">&#34;线程 t4 await 被中断&#34;</span>);
                    Thread.<span style="color:#007f7f">currentThread</span>().<span style="color:#007f7f">interrupt</span>();
                }
            }
        }, <span style="color:#0ff;font-weight:bold">&#34;t4&#34;</span>);

        t3.<span style="color:#007f7f">start</span>();
        t4.<span style="color:#007f7f">start</span>();
    }
}
</code></pre></div><p>上述程序，大概在过了 10 秒左右的时候，会输出：</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">线程 t3 从 await 中返回了
线程 t4 从 await 中返回了
</code></pre></div><blockquote>
<p>这两条输出，顺序不是绝对的</p>
<p>后面的分析，我们假设 t3 先进入阻塞队列</p>
</blockquote>
<p>接下来，我们按照流程一步一步走：先 await 等待，然后被唤醒，await 方法返回。</p>
<p>首先，我们来看 await() 方法，它代表线程阻塞，等待 state 的值减为 0。</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#fff;font-weight:bold">public</span> <span style="color:#fff;font-weight:bold">void</span> await() <span style="color:#fff;font-weight:bold">throws</span> InterruptedException {
    sync.<span style="color:#007f7f">acquireSharedInterruptibly</span>(1);
}
<span style="color:#fff;font-weight:bold">public</span> <span style="color:#fff;font-weight:bold">final</span> <span style="color:#fff;font-weight:bold">void</span> acquireSharedInterruptibly(<span style="color:#fff;font-weight:bold">int</span> arg)
        <span style="color:#fff;font-weight:bold">throws</span> InterruptedException {
    <span style="color:#007f7f">// 这也是老套路了，我在第二篇的中断那一节说过了
</span><span style="color:#007f7f"></span>    <span style="color:#fff;font-weight:bold">if</span> (Thread.<span style="color:#007f7f">interrupted</span>())
        <span style="color:#fff;font-weight:bold">throw</span> <span style="color:#fff;font-weight:bold">new</span> InterruptedException();
    
    <span style="color:#007f7f">// t3 和 t4 调用 await 的时候，state 都大于 0（state 此时为 2）。
</span><span style="color:#007f7f"></span>    <span style="color:#007f7f">// 也就是说，这个 if 返回 true，然后往里看
</span><span style="color:#007f7f"></span>    <span style="color:#fff;font-weight:bold">if</span> (tryAcquireShared(arg) &lt; 0)
        doAcquireSharedInterruptibly(arg);
}
<span style="color:#007f7f">// 只有当 state == 0 的时候，这个方法才会返回 1
</span><span style="color:#007f7f"></span><span style="color:#fff;font-weight:bold">protected</span> <span style="color:#fff;font-weight:bold">int</span> tryAcquireShared(<span style="color:#fff;font-weight:bold">int</span> acquires) {
    <span style="color:#fff;font-weight:bold">return</span> (getState() == 0) ? 1 : -1;
}
</code></pre></div><p>从方法名我们就可以看出，这个方法是获取共享锁，并且此方法是可中断的（中断的时候抛出 InterruptedException 退出这个方法）。</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#fff;font-weight:bold">private</span> <span style="color:#fff;font-weight:bold">void</span> doAcquireSharedInterruptibly(<span style="color:#fff;font-weight:bold">int</span> arg)
    <span style="color:#fff;font-weight:bold">throws</span> InterruptedException {
    <span style="color:#007f7f">// 1. 入队
</span><span style="color:#007f7f"></span>    <span style="color:#fff;font-weight:bold">final</span> Node node = addWaiter(Node.<span style="color:#007f7f">SHARED</span>);
    <span style="color:#fff;font-weight:bold">boolean</span> failed = <span style="color:#fff;font-weight:bold">true</span>;
    <span style="color:#fff;font-weight:bold">try</span> {
        <span style="color:#fff;font-weight:bold">for</span> (;;) {
            <span style="color:#fff;font-weight:bold">final</span> Node p = node.<span style="color:#007f7f">predecessor</span>();
            <span style="color:#fff;font-weight:bold">if</span> (p == head) {
                <span style="color:#007f7f">// 同上，只要 state 不等于 0，那么这个方法返回 -1
</span><span style="color:#007f7f"></span>                <span style="color:#fff;font-weight:bold">int</span> r = tryAcquireShared(arg);
                <span style="color:#fff;font-weight:bold">if</span> (r &gt;= 0) {
                    setHeadAndPropagate(node, r);
                    p.<span style="color:#007f7f">next</span> = <span style="color:#fff;font-weight:bold">null</span>; <span style="color:#007f7f">// help GC
</span><span style="color:#007f7f"></span>                    failed = <span style="color:#fff;font-weight:bold">false</span>;
                    <span style="color:#fff;font-weight:bold">return</span>;
                }
            }
            <span style="color:#007f7f">// 2
</span><span style="color:#007f7f"></span>            <span style="color:#fff;font-weight:bold">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;
                parkAndCheckInterrupt())
                <span style="color:#fff;font-weight:bold">throw</span> <span style="color:#fff;font-weight:bold">new</span> InterruptedException();
        }
    } <span style="color:#fff;font-weight:bold">finally</span> {
        <span style="color:#fff;font-weight:bold">if</span> (failed)
            cancelAcquire(node);
    }
}
</code></pre></div><p>我们来仔细分析这个方法，线程 t3 经过第 1 步 addWaiter 入队以后，我们应该可以得到这个：</p>
<p><img src="http://img.zhouyi.tech/note/2-3314833503964de3be4271aca700df40.png" alt="2"></p>
<p>由于 tryAcquireShared 这个方法会返回 -1，所以 if (r &gt;= 0) 这个分支不会进去。到 shouldParkAfterFailedAcquire 的时候，t3 将 head 的 waitStatus 值设置为 -1，如下：</p>
<p><img src="http://img.zhouyi.tech/note/3-bc6f464c2a4e4fae875a9a88fddcc483.png" alt="3"></p>
<p>然后进入到 parkAndCheckInterrupt 的时候，t3 挂起。</p>
<p>我们再分析 t4 入队，t4 会将前驱节点 t3 所在节点的 waitStatus 设置为 -1，t4 入队后，应该是这样的：</p>
<p><img src="http://img.zhouyi.tech/note/4-ab6e4b820bc849329b537c5cd314424d.png" alt="4"></p>
<p>然后，t4 也挂起。接下来，t3 和 t4 就等待唤醒了。</p>
<p>接下来，我们来看唤醒的流程。为了让下面的示意图更丰富些，我们假设用 10 初始化 CountDownLatch。</p>
<p><img src="http://img.zhouyi.tech/note/1-4b714d053fca4cab9cf602cb70849c60.png" alt="1"></p>
<p>当然，我们的例子中，其实没有 10 个线程，只有 2 个线程 t1 和 t2，只是为了让图好看些罢了。</p>
<p>我们再一步步看具体的流程。首先，我们看 countDown() 方法:</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#fff;font-weight:bold">public</span> <span style="color:#fff;font-weight:bold">void</span> countDown() {
    sync.<span style="color:#007f7f">releaseShared</span>(1);
}
<span style="color:#fff;font-weight:bold">public</span> <span style="color:#fff;font-weight:bold">final</span> <span style="color:#fff;font-weight:bold">boolean</span> releaseShared(<span style="color:#fff;font-weight:bold">int</span> arg) {
    <span style="color:#007f7f">// 只有当 state 减为 0 的时候，tryReleaseShared 才返回 true
</span><span style="color:#007f7f"></span>    <span style="color:#007f7f">// 否则只是简单的 state = state - 1 那么 countDown() 方法就结束了
</span><span style="color:#007f7f"></span>    <span style="color:#007f7f">//    将 state 减到 0 的那个操作才是最复杂的，继续往下吧
</span><span style="color:#007f7f"></span>    <span style="color:#fff;font-weight:bold">if</span> (tryReleaseShared(arg)) {
        <span style="color:#007f7f">// 唤醒 await 的线程
</span><span style="color:#007f7f"></span>        doReleaseShared();
        <span style="color:#fff;font-weight:bold">return</span> <span style="color:#fff;font-weight:bold">true</span>;
    }
    <span style="color:#fff;font-weight:bold">return</span> <span style="color:#fff;font-weight:bold">false</span>;
}
<span style="color:#007f7f">// 这个方法很简单，用自旋的方法实现 state 减 1
</span><span style="color:#007f7f"></span><span style="color:#fff;font-weight:bold">protected</span> <span style="color:#fff;font-weight:bold">boolean</span> tryReleaseShared(<span style="color:#fff;font-weight:bold">int</span> releases) {
    <span style="color:#fff;font-weight:bold">for</span> (;;) {
        <span style="color:#fff;font-weight:bold">int</span> c = getState();
        <span style="color:#fff;font-weight:bold">if</span> (c == 0)
            <span style="color:#fff;font-weight:bold">return</span> <span style="color:#fff;font-weight:bold">false</span>;
        <span style="color:#fff;font-weight:bold">int</span> nextc = c-1;
        <span style="color:#fff;font-weight:bold">if</span> (compareAndSetState(c, nextc))
            <span style="color:#fff;font-weight:bold">return</span> nextc == 0;
    }
}
</code></pre></div><p>countDown 方法就是每次调用都将 state 值减 1，如果 state 减到 0 了，那么就调用下面的方法进行唤醒阻塞队列中的线程：</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#007f7f">// 调用这个方法的时候，state == 0
</span><span style="color:#007f7f">// 这个方法先不要看所有的代码，按照思路往下到我写注释的地方，我们先跑通一个流程，其他的之后还会仔细分析
</span><span style="color:#007f7f"></span><span style="color:#fff;font-weight:bold">private</span> <span style="color:#fff;font-weight:bold">void</span> doReleaseShared() {
    <span style="color:#fff;font-weight:bold">for</span> (;;) {
        Node h = head;
        <span style="color:#fff;font-weight:bold">if</span> (h != <span style="color:#fff;font-weight:bold">null</span> &amp;&amp; h != tail) {
            <span style="color:#fff;font-weight:bold">int</span> ws = h.<span style="color:#007f7f">waitStatus</span>;
            <span style="color:#007f7f">// t3 入队的时候，已经将头节点的 waitStatus 设置为 Node.SIGNAL（-1） 了
</span><span style="color:#007f7f"></span>            <span style="color:#fff;font-weight:bold">if</span> (ws == Node.<span style="color:#007f7f">SIGNAL</span>) {
                <span style="color:#007f7f">// 将 head 的 waitStatue 设置为 0
</span><span style="color:#007f7f"></span>                <span style="color:#fff;font-weight:bold">if</span> (!compareAndSetWaitStatus(h, Node.<span style="color:#007f7f">SIGNAL</span>, 0))
                    <span style="color:#fff;font-weight:bold">continue</span>;            <span style="color:#007f7f">// loop to recheck cases
</span><span style="color:#007f7f"></span>                <span style="color:#007f7f">// 就是这里，唤醒 head 的后继节点，也就是阻塞队列中的第一个节点
</span><span style="color:#007f7f"></span>                <span style="color:#007f7f">// 在这里，也就是唤醒 t3
</span><span style="color:#007f7f"></span>                unparkSuccessor(h);
            }
            <span style="color:#fff;font-weight:bold">else</span> <span style="color:#fff;font-weight:bold">if</span> (ws == 0 &amp;&amp;
                     !compareAndSetWaitStatus(h, 0, Node.<span style="color:#007f7f">PROPAGATE</span>)) <span style="color:#007f7f">// todo
</span><span style="color:#007f7f"></span>                <span style="color:#fff;font-weight:bold">continue</span>;                <span style="color:#007f7f">// loop on failed CAS
</span><span style="color:#007f7f"></span>        }
        <span style="color:#fff;font-weight:bold">if</span> (h == head)                   <span style="color:#007f7f">// loop if head changed
</span><span style="color:#007f7f"></span>            <span style="color:#fff;font-weight:bold">break</span>;
    }
}
</code></pre></div><p>一旦 t3 被唤醒后，我们继续回到 await 的这段代码，parkAndCheckInterrupt 返回，我们先不考虑中断的情况：</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#fff;font-weight:bold">private</span> <span style="color:#fff;font-weight:bold">void</span> doAcquireSharedInterruptibly(<span style="color:#fff;font-weight:bold">int</span> arg)
    <span style="color:#fff;font-weight:bold">throws</span> InterruptedException {
    <span style="color:#fff;font-weight:bold">final</span> Node node = addWaiter(Node.<span style="color:#007f7f">SHARED</span>);
    <span style="color:#fff;font-weight:bold">boolean</span> failed = <span style="color:#fff;font-weight:bold">true</span>;
    <span style="color:#fff;font-weight:bold">try</span> {
        <span style="color:#fff;font-weight:bold">for</span> (;;) {
            <span style="color:#fff;font-weight:bold">final</span> Node p = node.<span style="color:#007f7f">predecessor</span>();
            <span style="color:#fff;font-weight:bold">if</span> (p == head) {
                <span style="color:#fff;font-weight:bold">int</span> r = tryAcquireShared(arg);
                <span style="color:#fff;font-weight:bold">if</span> (r &gt;= 0) {
                    setHeadAndPropagate(node, r); <span style="color:#007f7f">// 2. 这里是下一步
</span><span style="color:#007f7f"></span>                    p.<span style="color:#007f7f">next</span> = <span style="color:#fff;font-weight:bold">null</span>; <span style="color:#007f7f">// help GC
</span><span style="color:#007f7f"></span>                    failed = <span style="color:#fff;font-weight:bold">false</span>;
                    <span style="color:#fff;font-weight:bold">return</span>;
                }
            }
            <span style="color:#fff;font-weight:bold">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;
                <span style="color:#007f7f">// 1. 唤醒后这个方法返回
</span><span style="color:#007f7f"></span>                parkAndCheckInterrupt())
                <span style="color:#fff;font-weight:bold">throw</span> <span style="color:#fff;font-weight:bold">new</span> InterruptedException();
        }
    } <span style="color:#fff;font-weight:bold">finally</span> {
        <span style="color:#fff;font-weight:bold">if</span> (failed)
            cancelAcquire(node);
    }
}
</code></pre></div><p>接下来，t3 会进到 setHeadAndPropagate(node, r) 这个方法，先把 head 给占了，然后唤醒队列中其他的线程：</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#fff;font-weight:bold">private</span> <span style="color:#fff;font-weight:bold">void</span> setHeadAndPropagate(Node node, <span style="color:#fff;font-weight:bold">int</span> propagate) {
    Node h = head; <span style="color:#007f7f">// Record old head for check below
</span><span style="color:#007f7f"></span>    setHead(node);
  
    <span style="color:#007f7f">// 下面说的是，唤醒当前 node 之后的节点，即 t3 已经醒了，马上唤醒 t4
</span><span style="color:#007f7f"></span>    <span style="color:#007f7f">// 类似的，如果 t4 后面还有 t5，那么 t4 醒了以后，马上将 t5 给唤醒了
</span><span style="color:#007f7f"></span>    <span style="color:#fff;font-weight:bold">if</span> (propagate &gt; 0 || h == <span style="color:#fff;font-weight:bold">null</span> || h.<span style="color:#007f7f">waitStatus</span> &lt; 0 ||
        (h = head) == <span style="color:#fff;font-weight:bold">null</span> || h.<span style="color:#007f7f">waitStatus</span> &lt; 0) {
        Node s = node.<span style="color:#007f7f">next</span>;
        <span style="color:#fff;font-weight:bold">if</span> (s == <span style="color:#fff;font-weight:bold">null</span> || s.<span style="color:#007f7f">isShared</span>())
            <span style="color:#007f7f">// 又是这个方法，只是现在的 head 已经不是原来的空节点了，是 t3 的节点了
</span><span style="color:#007f7f"></span>            doReleaseShared();
    }
}
</code></pre></div><p>又回到这个方法了，那么接下来，我们好好分析 doReleaseShared 这个方法，我们根据流程，头节点 head 此时是 t3 节点了：</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#007f7f">// 调用这个方法的时候，state == 0
</span><span style="color:#007f7f"></span><span style="color:#fff;font-weight:bold">private</span> <span style="color:#fff;font-weight:bold">void</span> doReleaseShared() {
    <span style="color:#fff;font-weight:bold">for</span> (;;) {
        Node h = head;
        <span style="color:#007f7f">// 1. h == null: 说明阻塞队列为空
</span><span style="color:#007f7f"></span>        <span style="color:#007f7f">// 2. h == tail: 说明头结点可能是刚刚初始化的头节点，
</span><span style="color:#007f7f"></span>        <span style="color:#007f7f">//   或者是普通线程节点，但是此节点既然是头节点了，那么代表已经被唤醒了，阻塞队列没有其他节点了
</span><span style="color:#007f7f"></span>        <span style="color:#007f7f">// 所以这两种情况不需要进行唤醒后继节点
</span><span style="color:#007f7f"></span>        <span style="color:#fff;font-weight:bold">if</span> (h != <span style="color:#fff;font-weight:bold">null</span> &amp;&amp; h != tail) {
            <span style="color:#fff;font-weight:bold">int</span> ws = h.<span style="color:#007f7f">waitStatus</span>;
            <span style="color:#007f7f">// t4 将头节点(此时是 t3)的 waitStatus 设置为 Node.SIGNAL（-1） 了
</span><span style="color:#007f7f"></span>            <span style="color:#fff;font-weight:bold">if</span> (ws == Node.<span style="color:#007f7f">SIGNAL</span>) {
                <span style="color:#007f7f">// 这里 CAS 失败的场景请看下面的解读
</span><span style="color:#007f7f"></span>                <span style="color:#fff;font-weight:bold">if</span> (!compareAndSetWaitStatus(h, Node.<span style="color:#007f7f">SIGNAL</span>, 0))
                    <span style="color:#fff;font-weight:bold">continue</span>;            <span style="color:#007f7f">// loop to recheck cases
</span><span style="color:#007f7f"></span>                <span style="color:#007f7f">// 就是这里，唤醒 head 的后继节点，也就是阻塞队列中的第一个节点
</span><span style="color:#007f7f"></span>                <span style="color:#007f7f">// 在这里，也就是唤醒 t4
</span><span style="color:#007f7f"></span>                unparkSuccessor(h);
            }
            <span style="color:#fff;font-weight:bold">else</span> <span style="color:#fff;font-weight:bold">if</span> (ws == 0 &amp;&amp;
                     <span style="color:#007f7f">// 这个 CAS 失败的场景是：执行到这里的时候，刚好有一个节点入队，入队会将这个 ws 设置为 -1
</span><span style="color:#007f7f"></span>                     !compareAndSetWaitStatus(h, 0, Node.<span style="color:#007f7f">PROPAGATE</span>))
                <span style="color:#fff;font-weight:bold">continue</span>;                <span style="color:#007f7f">// loop on failed CAS
</span><span style="color:#007f7f"></span>        }
        <span style="color:#007f7f">// 如果到这里的时候，前面唤醒的线程已经占领了 head，那么再循环
</span><span style="color:#007f7f"></span>        <span style="color:#007f7f">// 否则，就是 head 没变，那么退出循环，
</span><span style="color:#007f7f"></span>        <span style="color:#007f7f">// 退出循环是不是意味着阻塞队列中的其他节点就不唤醒了？当然不是，唤醒的线程之后还是会调用这个方法的
</span><span style="color:#007f7f"></span>        <span style="color:#fff;font-weight:bold">if</span> (h == head)                   <span style="color:#007f7f">// loop if head changed
</span><span style="color:#007f7f"></span>            <span style="color:#fff;font-weight:bold">break</span>;
    }
}
</code></pre></div><p>我们分析下最后一个 if 语句，然后才能解释第一个 CAS 为什么可能会失败：</p>
<ol>
<li>h == head：说明头节点还没有被刚刚用 unparkSuccessor 唤醒的线程（这里可以理解为 t4）占有，此时 break 退出循环。</li>
<li>h != head：头节点被刚刚唤醒的线程（这里可以理解为 t4）占有，那么这里重新进入下一轮循环，唤醒下一个节点（这里是 t4 ）。我们知道，等到 t4 被唤醒后，其实是会主动唤醒 t5、t6、t7&hellip;，那为什么这里要进行下一个循环来唤醒 t5 呢？我觉得是出于吞吐量的考虑。</li>
</ol>
<p>满足上面的 2 的场景，那么我们就能知道为什么上面的 CAS 操作 compareAndSetWaitStatus(h, Node.SIGNAL, 0) 会失败了？</p>
<p>因为当前进行 for 循环的线程到这里的时候，可能刚刚唤醒的线程 t4 也刚刚好到这里了，那么就有可能 CAS 失败了。</p>
<p>for 循环第一轮的时候会唤醒 t4，t4 醒后会将自己设置为头节点，如果在 t4 设置头节点后，for 循环才跑到 if (h == head)，那么此时会返回 false，for 循环会进入下一轮。t4 唤醒后也会进入到这个方法里面，那么 for 循环第二轮和 t4 就有可能在这个 CAS 相遇，那么就只会有一个成功了。</p>
<h2 id="cyclicbarrier">CyclicBarrier</h2>
<p>字面意思是“可重复使用的栅栏”或“周期性的栅栏”，总之不是用了一次就没用了的，CyclicBarrier 相比 CountDownLatch 来说，要简单很多，其源码没有什么高深的地方，它是 ReentrantLock 和 Condition 的组合使用。看如下示意图，CyclicBarrier 和 CountDownLatch 是不是很像，只是 CyclicBarrier 可以有不止一个栅栏，因为它的栅栏（Barrier）可以重复使用（Cyclic）。</p>
<p><img src="http://img.zhouyi.tech/note/cyclicbarrier-2-04d9642801d34f729949ff1db7994d40.png" alt="cyclicbarrier-2"></p>
<p>首先，CyclicBarrier 的源码实现和 CountDownLatch 大相径庭，CountDownLatch 基于 AQS 的共享模式的使用，而 CyclicBarrier 基于 Condition 来实现。</p>
<p>因为 CyclicBarrier 的源码相对来说简单许多，读者只要熟悉了前面关于 Condition 的分析，那么这里的源码是毫无压力的，就是几个特殊概念罢了。</p>
<p>先用一张图来描绘下 CyclicBarrier 里面的一些概念，和它的基本使用流程：</p>
<p><img src="http://img.zhouyi.tech/note/cyclicbarrier-3-85a8e05519f544329419e3db2ad57392.png" alt="cyclicbarrier-3"></p>
<blockquote>
<p>看图我们也知道了，CyclicBarrier 的源码最重要的就是 await() 方法了。</p>
</blockquote>
<p>大家先把图看完，然后我们开始源码分析：</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#fff;font-weight:bold">public</span> <span style="color:#fff;font-weight:bold">class</span> CyclicBarrier {
    <span style="color:#007f7f">// 我们说了，CyclicBarrier 是可以重复使用的，我们把每次从开始使用到穿过栅栏当做&#34;一代&#34;，或者&#34;一个周期&#34;
</span><span style="color:#007f7f"></span>    <span style="color:#fff;font-weight:bold">private</span> <span style="color:#fff;font-weight:bold">static</span> <span style="color:#fff;font-weight:bold">class</span> Generation {
        <span style="color:#fff;font-weight:bold">boolean</span> broken = <span style="color:#fff;font-weight:bold">false</span>;
    }

    <span style="color:#007f7f">/** The lock for guarding barrier entry */</span>
    <span style="color:#fff;font-weight:bold">private</span> <span style="color:#fff;font-weight:bold">final</span> ReentrantLock lock = <span style="color:#fff;font-weight:bold">new</span> ReentrantLock();
    
    <span style="color:#007f7f">// CyclicBarrier 是基于 Condition 的
</span><span style="color:#007f7f"></span>    <span style="color:#007f7f">// Condition 是“条件”的意思，CyclicBarrier 的等待线程通过 barrier 的“条件”是大家都到了栅栏上
</span><span style="color:#007f7f"></span>    <span style="color:#fff;font-weight:bold">private</span> <span style="color:#fff;font-weight:bold">final</span> Condition trip = lock.<span style="color:#007f7f">newCondition</span>();

    <span style="color:#007f7f">// 参与的线程数
</span><span style="color:#007f7f"></span>    <span style="color:#fff;font-weight:bold">private</span> <span style="color:#fff;font-weight:bold">final</span> <span style="color:#fff;font-weight:bold">int</span> parties;

    <span style="color:#007f7f">// 如果设置了这个，代表越过栅栏之前，要执行相应的操作
</span><span style="color:#007f7f"></span>    <span style="color:#fff;font-weight:bold">private</span> <span style="color:#fff;font-weight:bold">final</span> Runnable barrierCommand;

    <span style="color:#007f7f">// 当前所处的“代”
</span><span style="color:#007f7f"></span>    <span style="color:#fff;font-weight:bold">private</span> Generation generation = <span style="color:#fff;font-weight:bold">new</span> Generation();

    <span style="color:#007f7f">// 还没有到栅栏的线程数，这个值初始为 parties，然后递减
</span><span style="color:#007f7f"></span>    <span style="color:#007f7f">// 还没有到栅栏的线程数 = parties - 已经到栅栏的数量
</span><span style="color:#007f7f"></span>    <span style="color:#fff;font-weight:bold">private</span> <span style="color:#fff;font-weight:bold">int</span> count;
  
    <span style="color:#fff;font-weight:bold">public</span> CyclicBarrier(<span style="color:#fff;font-weight:bold">int</span> parties, Runnable barrierAction) {
        <span style="color:#fff;font-weight:bold">if</span> (parties &lt;= 0) <span style="color:#fff;font-weight:bold">throw</span> <span style="color:#fff;font-weight:bold">new</span> IllegalArgumentException();
        <span style="color:#fff;font-weight:bold">this</span>.<span style="color:#007f7f">parties</span> = parties;
        <span style="color:#fff;font-weight:bold">this</span>.<span style="color:#007f7f">count</span> = parties;
        <span style="color:#fff;font-weight:bold">this</span>.<span style="color:#007f7f">barrierCommand</span> = barrierAction;
    }

    <span style="color:#fff;font-weight:bold">public</span> CyclicBarrier(<span style="color:#fff;font-weight:bold">int</span> parties) {
        <span style="color:#fff;font-weight:bold">this</span>(parties, <span style="color:#fff;font-weight:bold">null</span>);
    }
</code></pre></div><p>首先，先看怎么开启新的一代：</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#007f7f">// 开启新的一代，当最后一个线程到达栅栏上的时候，调用这个方法来唤醒其他线程，同时初始化“下一代”
</span><span style="color:#007f7f"></span><span style="color:#fff;font-weight:bold">private</span> <span style="color:#fff;font-weight:bold">void</span> nextGeneration() {
    <span style="color:#007f7f">// 首先，需要唤醒所有的在栅栏上等待的线程
</span><span style="color:#007f7f"></span>    trip.<span style="color:#007f7f">signalAll</span>();
    <span style="color:#007f7f">// 更新 count 的值
</span><span style="color:#007f7f"></span>    count = parties;
    <span style="color:#007f7f">// 重新生成“新一代”
</span><span style="color:#007f7f"></span>    generation = <span style="color:#fff;font-weight:bold">new</span> Generation();
}
</code></pre></div><blockquote>
<p>开启新的一代，类似于重新实例化一个 CyclicBarrier 实例</p>
</blockquote>
<p>看看怎么打破一个栅栏：</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#fff;font-weight:bold">private</span> <span style="color:#fff;font-weight:bold">void</span> breakBarrier() {
    <span style="color:#007f7f">// 设置状态 broken 为 true
</span><span style="color:#007f7f"></span>    generation.<span style="color:#007f7f">broken</span> = <span style="color:#fff;font-weight:bold">true</span>;
    <span style="color:#007f7f">// 重置 count 为初始值 parties
</span><span style="color:#007f7f"></span>    count = parties;
    <span style="color:#007f7f">// 唤醒所有已经在等待的线程
</span><span style="color:#007f7f"></span>    trip.<span style="color:#007f7f">signalAll</span>();
}
</code></pre></div><p>这两个方法之后用得到，现在开始分析最重要的等待通过栅栏方法 await 方法：</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#007f7f">// 不带超时机制
</span><span style="color:#007f7f"></span><span style="color:#fff;font-weight:bold">public</span> <span style="color:#fff;font-weight:bold">int</span> await() <span style="color:#fff;font-weight:bold">throws</span> InterruptedException, BrokenBarrierException {
    <span style="color:#fff;font-weight:bold">try</span> {
        <span style="color:#fff;font-weight:bold">return</span> dowait(<span style="color:#fff;font-weight:bold">false</span>, 0L);
    } <span style="color:#fff;font-weight:bold">catch</span> (TimeoutException toe) {
        <span style="color:#fff;font-weight:bold">throw</span> <span style="color:#fff;font-weight:bold">new</span> Error(toe); <span style="color:#007f7f">// cannot happen
</span><span style="color:#007f7f"></span>    }
}
<span style="color:#007f7f">// 带超时机制，如果超时抛出 TimeoutException 异常
</span><span style="color:#007f7f"></span><span style="color:#fff;font-weight:bold">public</span> <span style="color:#fff;font-weight:bold">int</span> await(<span style="color:#fff;font-weight:bold">long</span> timeout, TimeUnit unit)
    <span style="color:#fff;font-weight:bold">throws</span> InterruptedException,
           BrokenBarrierException,
           TimeoutException {
    <span style="color:#fff;font-weight:bold">return</span> dowait(<span style="color:#fff;font-weight:bold">true</span>, unit.<span style="color:#007f7f">toNanos</span>(timeout));
}
</code></pre></div><p>继续往里看：</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#fff;font-weight:bold">private</span> <span style="color:#fff;font-weight:bold">int</span> dowait(<span style="color:#fff;font-weight:bold">boolean</span> timed, <span style="color:#fff;font-weight:bold">long</span> nanos)
        <span style="color:#fff;font-weight:bold">throws</span> InterruptedException, BrokenBarrierException,
               TimeoutException {
    <span style="color:#fff;font-weight:bold">final</span> ReentrantLock lock = <span style="color:#fff;font-weight:bold">this</span>.<span style="color:#007f7f">lock</span>;
    <span style="color:#007f7f">// 先要获取到锁，然后在 finally 中要记得释放锁
</span><span style="color:#007f7f"></span>    <span style="color:#007f7f">// 如果记得 Condition 部分的话，我们知道 condition 的 await() 会释放锁，被 signal() 唤醒的时候需要重新获取锁
</span><span style="color:#007f7f"></span>    lock.<span style="color:#007f7f">lock</span>();
    <span style="color:#fff;font-weight:bold">try</span> {
        <span style="color:#fff;font-weight:bold">final</span> Generation g = generation;
        <span style="color:#007f7f">// 检查栅栏是否被打破，如果被打破，抛出 BrokenBarrierException 异常
</span><span style="color:#007f7f"></span>        <span style="color:#fff;font-weight:bold">if</span> (g.<span style="color:#007f7f">broken</span>)
            <span style="color:#fff;font-weight:bold">throw</span> <span style="color:#fff;font-weight:bold">new</span> BrokenBarrierException();
        <span style="color:#007f7f">// 检查中断状态，如果中断了，抛出 InterruptedException 异常
</span><span style="color:#007f7f"></span>        <span style="color:#fff;font-weight:bold">if</span> (Thread.<span style="color:#007f7f">interrupted</span>()) {
            breakBarrier();
            <span style="color:#fff;font-weight:bold">throw</span> <span style="color:#fff;font-weight:bold">new</span> InterruptedException();
        }
        <span style="color:#007f7f">// index 是这个 await 方法的返回值
</span><span style="color:#007f7f"></span>        <span style="color:#007f7f">// 注意到这里，这个是从 count 递减后得到的值
</span><span style="color:#007f7f"></span>        <span style="color:#fff;font-weight:bold">int</span> index = --count;
      
        <span style="color:#007f7f">// 如果等于 0，说明所有的线程都到栅栏上了，准备通过
</span><span style="color:#007f7f"></span>        <span style="color:#fff;font-weight:bold">if</span> (index == 0) {  <span style="color:#007f7f">// tripped
</span><span style="color:#007f7f"></span>            <span style="color:#fff;font-weight:bold">boolean</span> ranAction = <span style="color:#fff;font-weight:bold">false</span>;
            <span style="color:#fff;font-weight:bold">try</span> {
                <span style="color:#007f7f">// 如果在初始化的时候，指定了通过栅栏前需要执行的操作，在这里会得到执行
</span><span style="color:#007f7f"></span>                <span style="color:#fff;font-weight:bold">final</span> Runnable command = barrierCommand;
                <span style="color:#fff;font-weight:bold">if</span> (command != <span style="color:#fff;font-weight:bold">null</span>)
                    command.<span style="color:#007f7f">run</span>();
                <span style="color:#007f7f">// 如果 ranAction 为 true，说明执行 command.run() 的时候，没有发生异常退出的情况
</span><span style="color:#007f7f"></span>                ranAction = <span style="color:#fff;font-weight:bold">true</span>;
                <span style="color:#007f7f">// 唤醒等待的线程，然后开启新的一代
</span><span style="color:#007f7f"></span>                nextGeneration();
                <span style="color:#fff;font-weight:bold">return</span> 0;
            } <span style="color:#fff;font-weight:bold">finally</span> {
                <span style="color:#fff;font-weight:bold">if</span> (!ranAction)
                    <span style="color:#007f7f">// 进到这里，说明执行指定操作的时候，发生了异常，那么需要打破栅栏
</span><span style="color:#007f7f"></span>                    <span style="color:#007f7f">// 之前我们说了，打破栅栏意味着唤醒所有等待的线程，设置 broken 为 true，重置 count 为 parties
</span><span style="color:#007f7f"></span>                    breakBarrier();
            }
        }

        <span style="color:#007f7f">// loop until tripped, broken, interrupted, or timed out
</span><span style="color:#007f7f"></span>        <span style="color:#007f7f">// 如果是最后一个线程调用 await，那么上面就返回了
</span><span style="color:#007f7f"></span>        <span style="color:#007f7f">// 下面的操作是给那些不是最后一个到达栅栏的线程执行的
</span><span style="color:#007f7f"></span>        <span style="color:#fff;font-weight:bold">for</span> (;;) {
            <span style="color:#fff;font-weight:bold">try</span> {
                <span style="color:#007f7f">// 如果带有超时机制，调用带超时的 Condition 的 await 方法等待，直到最后一个线程调用 await
</span><span style="color:#007f7f"></span>                <span style="color:#fff;font-weight:bold">if</span> (!timed)
                    trip.<span style="color:#007f7f">await</span>();
                <span style="color:#fff;font-weight:bold">else</span> <span style="color:#fff;font-weight:bold">if</span> (nanos &gt; 0L)
                    nanos = trip.<span style="color:#007f7f">awaitNanos</span>(nanos);
            } <span style="color:#fff;font-weight:bold">catch</span> (InterruptedException ie) {
                <span style="color:#007f7f">// 如果到这里，说明等待的线程在 await（是 Condition 的 await）的时候被中断
</span><span style="color:#007f7f"></span>                <span style="color:#fff;font-weight:bold">if</span> (g == generation &amp;&amp; ! g.<span style="color:#007f7f">broken</span>) {
                    <span style="color:#007f7f">// 打破栅栏
</span><span style="color:#007f7f"></span>                    breakBarrier();
                    <span style="color:#007f7f">// 打破栅栏后，重新抛出这个 InterruptedException 异常给外层调用的方法
</span><span style="color:#007f7f"></span>                    <span style="color:#fff;font-weight:bold">throw</span> ie;
                } <span style="color:#fff;font-weight:bold">else</span> {
                    <span style="color:#007f7f">// 到这里，说明 g != generation, 说明新的一代已经产生，即最后一个线程 await 执行完成，
</span><span style="color:#007f7f"></span>                    <span style="color:#007f7f">// 那么此时没有必要再抛出 InterruptedException 异常，记录下来这个中断信息即可
</span><span style="color:#007f7f"></span>                    <span style="color:#007f7f">// 或者是栅栏已经被打破了，那么也不应该抛出 InterruptedException 异常，
</span><span style="color:#007f7f"></span>                    <span style="color:#007f7f">// 而是之后抛出 BrokenBarrierException 异常
</span><span style="color:#007f7f"></span>                    Thread.<span style="color:#007f7f">currentThread</span>().<span style="color:#007f7f">interrupt</span>();
                }
            }

          	<span style="color:#007f7f">// 唤醒后，检查栅栏是否是“破的”
</span><span style="color:#007f7f"></span>            <span style="color:#fff;font-weight:bold">if</span> (g.<span style="color:#007f7f">broken</span>)
                <span style="color:#fff;font-weight:bold">throw</span> <span style="color:#fff;font-weight:bold">new</span> BrokenBarrierException();

            <span style="color:#007f7f">// 这个 for 循环除了异常，就是要从这里退出了
</span><span style="color:#007f7f"></span>            <span style="color:#007f7f">// 我们要清楚，最后一个线程在执行完指定任务(如果有的话)，会调用 nextGeneration 来开启一个新的代
</span><span style="color:#007f7f"></span>            <span style="color:#007f7f">// 然后释放掉锁，其他线程从 Condition 的 await 方法中得到锁并返回，然后到这里的时候，其实就会满足 g != generation 的
</span><span style="color:#007f7f"></span>            <span style="color:#007f7f">// 那什么时候不满足呢？barrierCommand 执行过程中抛出了异常，那么会执行打破栅栏操作，
</span><span style="color:#007f7f"></span>            <span style="color:#007f7f">// 设置 broken 为true，然后唤醒这些线程。这些线程会从上面的 if (g.broken) 这个分支抛 BrokenBarrierException 异常返回
</span><span style="color:#007f7f"></span>            <span style="color:#007f7f">// 当然，还有最后一种可能，那就是 await 超时，此种情况不会从上面的 if 分支异常返回，也不会从这里返回，会执行后面的代码
</span><span style="color:#007f7f"></span>            <span style="color:#fff;font-weight:bold">if</span> (g != generation)
                <span style="color:#fff;font-weight:bold">return</span> index;

            <span style="color:#007f7f">// 如果醒来发现超时了，打破栅栏，抛出异常
</span><span style="color:#007f7f"></span>            <span style="color:#fff;font-weight:bold">if</span> (timed &amp;&amp; nanos &lt;= 0L) {
                breakBarrier();
                <span style="color:#fff;font-weight:bold">throw</span> <span style="color:#fff;font-weight:bold">new</span> TimeoutException();
            }
        }
    } <span style="color:#fff;font-weight:bold">finally</span> {
        lock.<span style="color:#007f7f">unlock</span>();
    }
}
</code></pre></div><p>好了，我想我应该讲清楚了吧，我好像几乎没有漏掉任何一行代码吧？</p>
<p>下面开始收尾工作。</p>
<p>首先，我们看看怎么得到有多少个线程到了栅栏上，处于等待状态：</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#fff;font-weight:bold">public</span> <span style="color:#fff;font-weight:bold">int</span> getNumberWaiting() {
    <span style="color:#fff;font-weight:bold">final</span> ReentrantLock lock = <span style="color:#fff;font-weight:bold">this</span>.<span style="color:#007f7f">lock</span>;
    lock.<span style="color:#007f7f">lock</span>();
    <span style="color:#fff;font-weight:bold">try</span> {
        <span style="color:#fff;font-weight:bold">return</span> parties - count;
    } <span style="color:#fff;font-weight:bold">finally</span> {
        lock.<span style="color:#007f7f">unlock</span>();
    }
}
</code></pre></div><p>判断一个栅栏是否被打破了，这个很简单，直接看 broken 的值即可：</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#fff;font-weight:bold">public</span> <span style="color:#fff;font-weight:bold">boolean</span> isBroken() {
    <span style="color:#fff;font-weight:bold">final</span> ReentrantLock lock = <span style="color:#fff;font-weight:bold">this</span>.<span style="color:#007f7f">lock</span>;
    lock.<span style="color:#007f7f">lock</span>();
    <span style="color:#fff;font-weight:bold">try</span> {
        <span style="color:#fff;font-weight:bold">return</span> generation.<span style="color:#007f7f">broken</span>;
    } <span style="color:#fff;font-weight:bold">finally</span> {
        lock.<span style="color:#007f7f">unlock</span>();
    }
}
</code></pre></div><p>前面我们在说 await 的时候也几乎说清楚了，什么时候栅栏会被打破，总结如下：</p>
<ol>
<li>中断，我们说了，如果某个等待的线程发生了中断，那么会打破栅栏，同时抛出 InterruptedException 异常；</li>
<li>超时，打破栅栏，同时抛出 TimeoutException 异常；</li>
<li>指定执行的操作抛出了异常，这个我们前面也说过。</li>
</ol>
<p>最后，我们来看看怎么重置一个栅栏：</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#fff;font-weight:bold">public</span> <span style="color:#fff;font-weight:bold">void</span> reset() {
    <span style="color:#fff;font-weight:bold">final</span> ReentrantLock lock = <span style="color:#fff;font-weight:bold">this</span>.<span style="color:#007f7f">lock</span>;
    lock.<span style="color:#007f7f">lock</span>();
    <span style="color:#fff;font-weight:bold">try</span> {
        breakBarrier();   <span style="color:#007f7f">// break the current generation
</span><span style="color:#007f7f"></span>        nextGeneration(); <span style="color:#007f7f">// start a new generation
</span><span style="color:#007f7f"></span>    } <span style="color:#fff;font-weight:bold">finally</span> {
        lock.<span style="color:#007f7f">unlock</span>();
    }
}
</code></pre></div><p>我们设想一下，如果初始化时，指定了线程 parties = 4，前面有 3 个线程调用了 await 等待，在第 4 个线程调用 await 之前，我们调用 reset 方法，那么会发生什么？</p>
<p>首先，打破栅栏，那意味着所有等待的线程（3个等待的线程）会唤醒，await 方法会通过抛出 BrokenBarrierException 异常返回。然后开启新的一代，重置了 count 和 generation，相当于一切归零了。</p>
<p>怎么样，CyclicBarrier 源码很简单吧。</p>
<h2 id="semaphore">Semaphore</h2>
<p>有了 CountDownLatch 的基础后，分析 Semaphore 会简单很多。Semaphore 是什么呢？它类似一个资源池（读者可以类比线程池），每个线程需要调用 acquire() 方法获取资源，然后才能执行，执行完后，需要 release 资源，让给其他的线程用。</p>
<p>大概大家也可以猜到，Semaphore 其实也是 AQS 中共享锁的使用，因为每个线程共享一个池嘛。</p>
<p>套路解读：创建 Semaphore 实例的时候，需要一个参数 permits，这个基本上可以确定是设置给 AQS 的 state 的，然后每个线程调用 acquire 的时候，执行 state = state - 1，release 的时候执行 state = state + 1，当然，acquire  的时候，如果 state = 0，说明没有资源了，需要等待其他线程 release。</p>
<p>构造方法：</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#fff;font-weight:bold">public</span> Semaphore(<span style="color:#fff;font-weight:bold">int</span> permits) {
    sync = <span style="color:#fff;font-weight:bold">new</span> NonfairSync(permits);
}

<span style="color:#fff;font-weight:bold">public</span> Semaphore(<span style="color:#fff;font-weight:bold">int</span> permits, <span style="color:#fff;font-weight:bold">boolean</span> fair) {
    sync = fair ? <span style="color:#fff;font-weight:bold">new</span> FairSync(permits) : <span style="color:#fff;font-weight:bold">new</span> NonfairSync(permits);
}
</code></pre></div><p>这里和 ReentrantLock 类似，用了公平策略和非公平策略。</p>
<p>看 acquire 方法：</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#fff;font-weight:bold">public</span> <span style="color:#fff;font-weight:bold">void</span> acquire() <span style="color:#fff;font-weight:bold">throws</span> InterruptedException {
    sync.<span style="color:#007f7f">acquireSharedInterruptibly</span>(1);
}
<span style="color:#fff;font-weight:bold">public</span> <span style="color:#fff;font-weight:bold">void</span> acquireUninterruptibly() {
    sync.<span style="color:#007f7f">acquireShared</span>(1);
}
<span style="color:#fff;font-weight:bold">public</span> <span style="color:#fff;font-weight:bold">void</span> acquire(<span style="color:#fff;font-weight:bold">int</span> permits) <span style="color:#fff;font-weight:bold">throws</span> InterruptedException {
    <span style="color:#fff;font-weight:bold">if</span> (permits &lt; 0) <span style="color:#fff;font-weight:bold">throw</span> <span style="color:#fff;font-weight:bold">new</span> IllegalArgumentException();
    sync.<span style="color:#007f7f">acquireSharedInterruptibly</span>(permits);
}
<span style="color:#fff;font-weight:bold">public</span> <span style="color:#fff;font-weight:bold">void</span> acquireUninterruptibly(<span style="color:#fff;font-weight:bold">int</span> permits) {
    <span style="color:#fff;font-weight:bold">if</span> (permits &lt; 0) <span style="color:#fff;font-weight:bold">throw</span> <span style="color:#fff;font-weight:bold">new</span> IllegalArgumentException();
    sync.<span style="color:#007f7f">acquireShared</span>(permits);
}
</code></pre></div><p>这几个方法也是老套路了，大家基本都懂了吧，这边多了两个可以传参的 acquire 方法，不过大家也都懂的吧，如果我们需要一次获取超过一个的资源，会用得着这个的。</p>
<p>我们接下来看不抛出 InterruptedException 异常的 acquireUninterruptibly() 方法吧：</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#fff;font-weight:bold">public</span> <span style="color:#fff;font-weight:bold">void</span> acquireUninterruptibly() {
    sync.<span style="color:#007f7f">acquireShared</span>(1);
}
<span style="color:#fff;font-weight:bold">public</span> <span style="color:#fff;font-weight:bold">final</span> <span style="color:#fff;font-weight:bold">void</span> acquireShared(<span style="color:#fff;font-weight:bold">int</span> arg) {
    <span style="color:#fff;font-weight:bold">if</span> (tryAcquireShared(arg) &lt; 0)
        doAcquireShared(arg);
}
</code></pre></div><p>前面说了，Semaphore 分公平策略和非公平策略，我们对比一下两个 tryAcquireShared 方法：</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#007f7f">// 公平策略：
</span><span style="color:#007f7f"></span><span style="color:#fff;font-weight:bold">protected</span> <span style="color:#fff;font-weight:bold">int</span> tryAcquireShared(<span style="color:#fff;font-weight:bold">int</span> acquires) {
    <span style="color:#fff;font-weight:bold">for</span> (;;) {
        <span style="color:#007f7f">// 区别就在于是不是会先判断是否有线程在排队，然后才进行 CAS 减操作
</span><span style="color:#007f7f"></span>        <span style="color:#fff;font-weight:bold">if</span> (hasQueuedPredecessors())
            <span style="color:#fff;font-weight:bold">return</span> -1;
        <span style="color:#fff;font-weight:bold">int</span> available = getState();
        <span style="color:#fff;font-weight:bold">int</span> remaining = available - acquires;
        <span style="color:#fff;font-weight:bold">if</span> (remaining &lt; 0 ||
            compareAndSetState(available, remaining))
            <span style="color:#fff;font-weight:bold">return</span> remaining;
    }
}
<span style="color:#007f7f">// 非公平策略：
</span><span style="color:#007f7f"></span><span style="color:#fff;font-weight:bold">protected</span> <span style="color:#fff;font-weight:bold">int</span> tryAcquireShared(<span style="color:#fff;font-weight:bold">int</span> acquires) {
    <span style="color:#fff;font-weight:bold">return</span> nonfairTryAcquireShared(acquires);
}
<span style="color:#fff;font-weight:bold">final</span> <span style="color:#fff;font-weight:bold">int</span> nonfairTryAcquireShared(<span style="color:#fff;font-weight:bold">int</span> acquires) {
    <span style="color:#fff;font-weight:bold">for</span> (;;) {
        <span style="color:#fff;font-weight:bold">int</span> available = getState();
        <span style="color:#fff;font-weight:bold">int</span> remaining = available - acquires;
        <span style="color:#fff;font-weight:bold">if</span> (remaining &lt; 0 ||
            compareAndSetState(available, remaining))
            <span style="color:#fff;font-weight:bold">return</span> remaining;
    }
}
</code></pre></div><p>也是老套路了，所以从源码分析角度的话，我们其实不太需要关心是不是公平策略还是非公平策略，它们的区别往往就那么一两行。</p>
<p>我们再回到 acquireShared 方法，</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#fff;font-weight:bold">public</span> <span style="color:#fff;font-weight:bold">final</span> <span style="color:#fff;font-weight:bold">void</span> acquireShared(<span style="color:#fff;font-weight:bold">int</span> arg) {
    <span style="color:#fff;font-weight:bold">if</span> (tryAcquireShared(arg) &lt; 0)
        doAcquireShared(arg);
}
</code></pre></div><p>由于 tryAcquireShared(arg) 返回小于 0 的时候，说明 state 已经小于 0 了（没资源了），此时 acquire 不能立马拿到资源，需要进入到阻塞队列等待，虽然贴了很多代码，不在乎多这点了：</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#fff;font-weight:bold">private</span> <span style="color:#fff;font-weight:bold">void</span> doAcquireShared(<span style="color:#fff;font-weight:bold">int</span> arg) {
    <span style="color:#fff;font-weight:bold">final</span> Node node = addWaiter(Node.<span style="color:#007f7f">SHARED</span>);
    <span style="color:#fff;font-weight:bold">boolean</span> failed = <span style="color:#fff;font-weight:bold">true</span>;
    <span style="color:#fff;font-weight:bold">try</span> {
        <span style="color:#fff;font-weight:bold">boolean</span> interrupted = <span style="color:#fff;font-weight:bold">false</span>;
        <span style="color:#fff;font-weight:bold">for</span> (;;) {
            <span style="color:#fff;font-weight:bold">final</span> Node p = node.<span style="color:#007f7f">predecessor</span>();
            <span style="color:#fff;font-weight:bold">if</span> (p == head) {
                <span style="color:#fff;font-weight:bold">int</span> r = tryAcquireShared(arg);
                <span style="color:#fff;font-weight:bold">if</span> (r &gt;= 0) {
                    setHeadAndPropagate(node, r);
                    p.<span style="color:#007f7f">next</span> = <span style="color:#fff;font-weight:bold">null</span>; <span style="color:#007f7f">// help GC
</span><span style="color:#007f7f"></span>                    <span style="color:#fff;font-weight:bold">if</span> (interrupted)
                        selfInterrupt();
                    failed = <span style="color:#fff;font-weight:bold">false</span>;
                    <span style="color:#fff;font-weight:bold">return</span>;
                }
            }
            <span style="color:#fff;font-weight:bold">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;
                parkAndCheckInterrupt())
                interrupted = <span style="color:#fff;font-weight:bold">true</span>;
        }
    } <span style="color:#fff;font-weight:bold">finally</span> {
        <span style="color:#fff;font-weight:bold">if</span> (failed)
            cancelAcquire(node);
    }
}
</code></pre></div><p>这个方法我就不介绍了，线程挂起后等待有资源被 release 出来。接下来，我们就要看 release 的方法了：</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#007f7f">// 任务介绍，释放一个资源
</span><span style="color:#007f7f"></span><span style="color:#fff;font-weight:bold">public</span> <span style="color:#fff;font-weight:bold">void</span> release() {
    sync.<span style="color:#007f7f">releaseShared</span>(1);
}
<span style="color:#fff;font-weight:bold">public</span> <span style="color:#fff;font-weight:bold">final</span> <span style="color:#fff;font-weight:bold">boolean</span> releaseShared(<span style="color:#fff;font-weight:bold">int</span> arg) {
    <span style="color:#fff;font-weight:bold">if</span> (tryReleaseShared(arg)) {
        doReleaseShared();
        <span style="color:#fff;font-weight:bold">return</span> <span style="color:#fff;font-weight:bold">true</span>;
    }
    <span style="color:#fff;font-weight:bold">return</span> <span style="color:#fff;font-weight:bold">false</span>;
}

<span style="color:#fff;font-weight:bold">protected</span> <span style="color:#fff;font-weight:bold">final</span> <span style="color:#fff;font-weight:bold">boolean</span> tryReleaseShared(<span style="color:#fff;font-weight:bold">int</span> releases) {
    <span style="color:#fff;font-weight:bold">for</span> (;;) {
        <span style="color:#fff;font-weight:bold">int</span> current = getState();
        <span style="color:#fff;font-weight:bold">int</span> next = current + releases;
        <span style="color:#007f7f">// 溢出，当然，我们一般也不会用这么大的数
</span><span style="color:#007f7f"></span>        <span style="color:#fff;font-weight:bold">if</span> (next &lt; current) <span style="color:#007f7f">// overflow
</span><span style="color:#007f7f"></span>            <span style="color:#fff;font-weight:bold">throw</span> <span style="color:#fff;font-weight:bold">new</span> Error(<span style="color:#0ff;font-weight:bold">&#34;Maximum permit count exceeded&#34;</span>);
        <span style="color:#fff;font-weight:bold">if</span> (compareAndSetState(current, next))
            <span style="color:#fff;font-weight:bold">return</span> <span style="color:#fff;font-weight:bold">true</span>;
    }
}
</code></pre></div><p>tryReleaseShared 方法总是会返回 true，然后是 doReleaseShared，这个也是我们熟悉的方法了，我就贴下代码，不分析了，这个方法用于唤醒所有的等待线程：</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#fff;font-weight:bold">private</span> <span style="color:#fff;font-weight:bold">void</span> doReleaseShared() {
    <span style="color:#fff;font-weight:bold">for</span> (;;) {
        Node h = head;
        <span style="color:#fff;font-weight:bold">if</span> (h != <span style="color:#fff;font-weight:bold">null</span> &amp;&amp; h != tail) {
            <span style="color:#fff;font-weight:bold">int</span> ws = h.<span style="color:#007f7f">waitStatus</span>;
            <span style="color:#fff;font-weight:bold">if</span> (ws == Node.<span style="color:#007f7f">SIGNAL</span>) {
                <span style="color:#fff;font-weight:bold">if</span> (!compareAndSetWaitStatus(h, Node.<span style="color:#007f7f">SIGNAL</span>, 0))
                    <span style="color:#fff;font-weight:bold">continue</span>;            <span style="color:#007f7f">// loop to recheck cases
</span><span style="color:#007f7f"></span>                unparkSuccessor(h);
            }
            <span style="color:#fff;font-weight:bold">else</span> <span style="color:#fff;font-weight:bold">if</span> (ws == 0 &amp;&amp;
                     !compareAndSetWaitStatus(h, 0, Node.<span style="color:#007f7f">PROPAGATE</span>))
                <span style="color:#fff;font-weight:bold">continue</span>;                <span style="color:#007f7f">// loop on failed CAS
</span><span style="color:#007f7f"></span>        }
        <span style="color:#fff;font-weight:bold">if</span> (h == head)                   <span style="color:#007f7f">// loop if head changed
</span><span style="color:#007f7f"></span>            <span style="color:#fff;font-weight:bold">break</span>;
    }
}
</code></pre></div><p>Semphore 的源码确实很简单，基本上都是分析过的老代码的组合使用了。</p>
<h2 id="总结">总结</h2>
<p>写到这里，终于把 AbstractQueuedSynchronizer 基本上说完了，对于 Java 并发，Doug Lea 真的是神一样的存在。日后我们还会接触到很多 Doug Lea 的代码，希望我们大家都可以朝着大神的方向不断打磨自己的技术，少一些高大上的架构，多一些实实在在的优秀代码吧。</p>
<p>（全文完）</p>
<p><strong>著作权归原作者所有，<a href="https://javadoop.com/post/AbstractQueuedSynchronizer-3">原文链接</a>。</strong></p>

  </article>
</section>


</main>

You must set a googleAnalytics UA-Code within the global config.toml Params.

</body>

</html>

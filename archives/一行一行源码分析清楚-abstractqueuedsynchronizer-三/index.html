<!DOCTYPE html>
<html lang="zh-cn">

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  
  <meta name="author" content="Eddy Zhou">
  
  <meta name="description" content="一行一行源码分析清楚AbstractQueuedSynchronizer">
  
  
  <meta name="keywords" content="aqs,, 并发">
  

  <meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="一行一行源码分析清楚 AbstractQueuedSynchronizer (三)"/>
<meta name="twitter:description" content="一行一行源码分析清楚AbstractQueuedSynchronizer"/>

  <meta property="og:title" content="一行一行源码分析清楚 AbstractQueuedSynchronizer (三)" />
<meta property="og:description" content="一行一行源码分析清楚AbstractQueuedSynchronizer" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://www.zhouyi.tech/archives/%E4%B8%80%E8%A1%8C%E4%B8%80%E8%A1%8C%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E6%B8%85%E6%A5%9A-abstractqueuedsynchronizer-%E4%B8%89/" />
<meta property="article:published_time" content="2020-07-02T00:00:00+00:00" />
<meta property="article:modified_time" content="2020-07-02T00:00:00+00:00" /><meta property="og:site_name" content="程序员学习之路" />


  



  
  <base href="https://www.zhouyi.tech/archives/%E4%B8%80%E8%A1%8C%E4%B8%80%E8%A1%8C%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E6%B8%85%E6%A5%9A-abstractqueuedsynchronizer-%E4%B8%89/">
  
  <title>
  一行一行源码分析清楚 AbstractQueuedSynchronizer (三) · 程序员学习之路
</title>

  
  <link rel="canonical" href="https://www.zhouyi.tech/archives/%E4%B8%80%E8%A1%8C%E4%B8%80%E8%A1%8C%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E6%B8%85%E6%A5%9A-abstractqueuedsynchronizer-%E4%B8%89/">
  

  <link href="https://fonts.googleapis.com/css?family=Lato:400,700%7CMerriweather:300,700%7CSource+Code+Pro:400,700&display=swap"
    rel="stylesheet">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.1/normalize.min.css"
    integrity="sha256-l85OmPOjvil/SOvVt3HnSSjzF1TUMyT9eV0c2BzEGzU=" crossorigin="anonymous" />

  
  
  
  <link rel="stylesheet" href="https://www.zhouyi.tech/css/coder.min.4aab773750c0433c68c0e2280201a35fa394baf9ef7016cf8f8ae4ba96e597dc.css" integrity="sha256-Sqt3N1DAQzxowOIoAgGjX6OUuvnvcBbPj4rkupbll9w="
    crossorigin="anonymous" media="screen" />
  

  

  
  
  
  
  <link rel="stylesheet" href="https://www.zhouyi.tech/css/coder-dark.min.83a2010dac9f59f943b3004cd6c4f230507ad036da635d3621401d42ec4e2835.css" integrity="sha256-g6IBDayfWflDswBM1sTyMFB60DbaY102IUAdQuxOKDU="
    crossorigin="anonymous" media="screen" />
  
  

  
  <link rel="stylesheet" href="https://www.zhouyi.tech/css/main.css" />
  

  
  <script src="https://www.zhouyi.tech/js/lazysizes.min.js" async></script>
  
  <script src="https://www.zhouyi.tech/js/flying-pages.min.js" async></script>
  

  <link rel="icon" type="image/png" href="https://www.zhouyi.tech/images/f/favicon-32x32.png"
    sizes="32x32">
  <link rel="icon" type="image/png" href="https://www.zhouyi.tech/images/f/favicon-16x16.png"
    sizes="16x16">

  <link rel="amphtml" type="text/html" href="https://www.zhouyi.tech/amp/archives/%E4%B8%80%E8%A1%8C%E4%B8%80%E8%A1%8C%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E6%B8%85%E6%A5%9A-abstractqueuedsynchronizer-%E4%B8%89/" title="程序员学习之路" />
  <meta name="generator" content="Hugo 0.75.1" />

  <meta name="baidu-site-verification" content="TiReu51WyJ" />

  
  
  <link rel="stylesheet" href="https://www.zhouyi.tech/scss/tagcloud.css" media="screen" />

</head>






<body class="colorscheme-auto">
  <main class="wrapper">
    <nav class="navigation">
  <section class="container">
    <a class="navigation-title" href="https://www.zhouyi.tech/">
      程序员学习之路
    </a>
    <input type="checkbox" id="menu-toggle" />
    <label class="menu-button float-right" for="menu-toggle"><i class="fas fa-bars"></i></label>
    <ul class="navigation-list">
      
        
          <li class="navigation-item">
            <a class="navigation-link" href="https://www.zhouyi.tech/archives/">技术</a>
          </li>
        
          <li class="navigation-item">
            <a class="navigation-link" href="https://www.zhouyi.tech/about/">关于</a>
          </li>
        
      
      
    </ul>
  </section>
</nav>


    <div class="content">
      
  <section class="container page">
  <article>
    <header>
      <h1>一行一行源码分析清楚 AbstractQueuedSynchronizer (三)</h1>
    </header>

    <p>这篇文章是 AQS 系列的最后一篇，第一篇，我们通过 ReentrantLock 公平锁分析了 AQS 的核心，第二篇的重点是把 Condition 说明白，同时也说清楚了对于线程中断的使用。</p>
<p>这篇，我们的关注点是 AQS 最后的部分，<strong>AQS 共享模式</strong>的使用。有前两篇文章的铺垫，剩下的源码分析将会简单很多。</p>
<p>本文先用 CountDownLatch 将共享模式说清楚，然后顺着把其他 AQS 相关的类 CyclicBarrier、Semaphore 的源码一起过一下。</p>
<p>相对来说，如果读者有前面两篇文章的基础，这篇文章是简单很多，不过对于初学者来说，1 小时估计也是免不了的。</p>
<!-- more -->
<!-- toc -->
<h2 id="countdownlatch">CountDownLatch</h2>
<p>CountDownLatch 这个类是比较典型的 AQS 的共享模式的使用，这是一个高频使用的类。latch 的中文意思是<strong>门栓、栅栏</strong>，具体怎么解释我就不废话了，大家随意，看两个例子就知道在哪里用、怎么用了。</p>
<h3 id="使用例子">使用例子</h3>
<p>我们看下 Doug Lea 在 java doc 中给出的例子，这个例子非常实用，我经常会写到这个代码。</p>
<p>假设我们有 N ( N &gt; 0 ) 个任务，那么我们会用 N 来初始化一个 CountDownLatch，然后将这个 latch 的引用传递到各个线程中，在每个线程完成了任务后，调用 latch.countDown() 代表完成了一个任务。</p>
<p>调用 latch.await() 的方法的线程会阻塞，直到所有的任务完成。</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#fff;font-weight:bold">class</span> Driver2 { <span style="color:#007f7f">// ...
</span><span style="color:#007f7f"></span>    <span style="color:#fff;font-weight:bold">void</span> main() <span style="color:#fff;font-weight:bold">throws</span> InterruptedException {
        CountDownLatch doneSignal = <span style="color:#fff;font-weight:bold">new</span> CountDownLatch(N);
        Executor e = Executors.<span style="color:#007f7f">newFixedThreadPool</span>(8);

        <span style="color:#007f7f">// 创建 N 个任务，提交给线程池来执行
</span><span style="color:#007f7f"></span>        <span style="color:#fff;font-weight:bold">for</span> (<span style="color:#fff;font-weight:bold">int</span> i = 0; i &lt; N; ++i) <span style="color:#007f7f">// create and start threads
</span><span style="color:#007f7f"></span>            e.<span style="color:#007f7f">execute</span>(<span style="color:#fff;font-weight:bold">new</span> WorkerRunnable(doneSignal, i));

        <span style="color:#007f7f">// 等待所有的任务完成，这个方法才会返回
</span><span style="color:#007f7f"></span>        doneSignal.<span style="color:#007f7f">await</span>();           <span style="color:#007f7f">// wait for all to finish
</span><span style="color:#007f7f"></span>    }
}

<span style="color:#fff;font-weight:bold">class</span> WorkerRunnable <span style="color:#fff;font-weight:bold">implements</span> Runnable {
    <span style="color:#fff;font-weight:bold">private</span> <span style="color:#fff;font-weight:bold">final</span> CountDownLatch doneSignal;
    <span style="color:#fff;font-weight:bold">private</span> <span style="color:#fff;font-weight:bold">final</span> <span style="color:#fff;font-weight:bold">int</span> i;

    WorkerRunnable(CountDownLatch doneSignal, <span style="color:#fff;font-weight:bold">int</span> i) {
        <span style="color:#fff;font-weight:bold">this</span>.<span style="color:#007f7f">doneSignal</span> = doneSignal;
        <span style="color:#fff;font-weight:bold">this</span>.<span style="color:#007f7f">i</span> = i;
    }

    <span style="color:#fff;font-weight:bold">public</span> <span style="color:#fff;font-weight:bold">void</span> run() {
        <span style="color:#fff;font-weight:bold">try</span> {
            doWork(i);
            <span style="color:#007f7f">// 这个线程的任务完成了，调用 countDown 方法
</span><span style="color:#007f7f"></span>            doneSignal.<span style="color:#007f7f">countDown</span>();
        } <span style="color:#fff;font-weight:bold">catch</span> (InterruptedException ex) {
        } <span style="color:#007f7f">// return;
</span><span style="color:#007f7f"></span>    }

    <span style="color:#fff;font-weight:bold">void</span> doWork() { ...}
}
</code></pre></div><p>所以说 CountDownLatch 非常实用，我们常常会将一个比较大的任务进行拆分，然后开启多个线程来执行，等所有线程都执行完了以后，再往下执行其他操作。这里例子中，<strong>只有 main 线程调用了 await 方法</strong>。</p>
<p>我们再来看另一个例子，这个例子很典型，用了两个 CountDownLatch：</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#fff;font-weight:bold">class</span> Driver { <span style="color:#007f7f">// ...
</span><span style="color:#007f7f"></span>    <span style="color:#fff;font-weight:bold">void</span> main() <span style="color:#fff;font-weight:bold">throws</span> InterruptedException {
        CountDownLatch startSignal = <span style="color:#fff;font-weight:bold">new</span> CountDownLatch(1);
        CountDownLatch doneSignal = <span style="color:#fff;font-weight:bold">new</span> CountDownLatch(N);
 
        <span style="color:#fff;font-weight:bold">for</span> (<span style="color:#fff;font-weight:bold">int</span> i = 0; i &lt; N; ++i) <span style="color:#007f7f">// create and start threads
</span><span style="color:#007f7f"></span>            <span style="color:#fff;font-weight:bold">new</span> Thread(<span style="color:#fff;font-weight:bold">new</span> Worker(startSignal, doneSignal)).<span style="color:#007f7f">start</span>();

        <span style="color:#007f7f">// 这边插入一些代码，确保上面的每个线程先启动起来，才执行下面的代码。
</span><span style="color:#007f7f"></span>        doSomethingElse();            <span style="color:#007f7f">// don&#39;t let run yet
</span><span style="color:#007f7f"></span>        <span style="color:#007f7f">// 因为这里 N == 1，所以，只要调用一次，那么所有的 await 方法都可以通过
</span><span style="color:#007f7f"></span>        startSignal.<span style="color:#007f7f">countDown</span>();      <span style="color:#007f7f">// let all threads proceed
</span><span style="color:#007f7f"></span>        doSomethingElse();
        <span style="color:#007f7f">// 等待所有任务结束
</span><span style="color:#007f7f"></span>        doneSignal.<span style="color:#007f7f">await</span>();           <span style="color:#007f7f">// wait for all to finish
</span><span style="color:#007f7f"></span>    }
}

<span style="color:#fff;font-weight:bold">class</span> Worker <span style="color:#fff;font-weight:bold">implements</span> Runnable {
    <span style="color:#fff;font-weight:bold">private</span> <span style="color:#fff;font-weight:bold">final</span> CountDownLatch startSignal;
    <span style="color:#fff;font-weight:bold">private</span> <span style="color:#fff;font-weight:bold">final</span> CountDownLatch doneSignal;

    Worker(CountDownLatch startSignal, CountDownLatch doneSignal) {
        <span style="color:#fff;font-weight:bold">this</span>.<span style="color:#007f7f">startSignal</span> = startSignal;
        <span style="color:#fff;font-weight:bold">this</span>.<span style="color:#007f7f">doneSignal</span> = doneSignal;
    }

    <span style="color:#fff;font-weight:bold">public</span> <span style="color:#fff;font-weight:bold">void</span> run() {
        <span style="color:#fff;font-weight:bold">try</span> {
            <span style="color:#007f7f">// 为了让所有线程同时开始任务，我们让所有线程先阻塞在这里
</span><span style="color:#007f7f"></span>            <span style="color:#007f7f">// 等大家都准备好了，再打开这个门栓
</span><span style="color:#007f7f"></span>            startSignal.<span style="color:#007f7f">await</span>();
            doWork();
            doneSignal.<span style="color:#007f7f">countDown</span>();
        } <span style="color:#fff;font-weight:bold">catch</span> (InterruptedException ex) {
        } <span style="color:#007f7f">// return;
</span><span style="color:#007f7f"></span>    }

    <span style="color:#fff;font-weight:bold">void</span> doWork() { ...}
}
</code></pre></div><p>这个例子中，doneSignal 同第一个例子的使用，我们说说这里的 startSignal。N 个新开启的线程都调用了startSignal.await() 进行阻塞等待，它们阻塞在<strong>栅栏</strong>上，只有当条件满足的时候（startSignal.countDown()），它们才能同时通过这个栅栏，目的是让所有的线程站在一个起跑线上。</p>
<p><img src="http://img.zhouyi.tech/note/5-f7b3babb83a64f6aae9be7fc28fc6b08.png" alt="5"></p>
<p>如果始终只有一个线程调用 await 方法等待任务完成，那么 CountDownLatch 就会简单很多，所以之后的源码分析读者一定要在脑海中构建出这么一个场景：有 m 个线程是做任务的，有 n 个线程在某个栅栏上等待这 m 个线程做完任务，直到所有 m 个任务完成后，n 个线程同时通过栅栏。</p>
<h3 id="源码分析">源码分析</h3>
<p>Talk is cheap, show me the code.</p>
<p>构造方法，需要传入一个不小于 0 的整数：</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#fff;font-weight:bold">public</span> CountDownLatch(<span style="color:#fff;font-weight:bold">int</span> count) {
    <span style="color:#fff;font-weight:bold">if</span> (count &lt; 0) <span style="color:#fff;font-weight:bold">throw</span> <span style="color:#fff;font-weight:bold">new</span> IllegalArgumentException(<span style="color:#0ff;font-weight:bold">&#34;count &lt; 0&#34;</span>);
    <span style="color:#fff;font-weight:bold">this</span>.<span style="color:#007f7f">sync</span> = <span style="color:#fff;font-weight:bold">new</span> Sync(count);
}
<span style="color:#007f7f">// 老套路了，内部封装一个 Sync 类继承自 AQS
</span><span style="color:#007f7f"></span><span style="color:#fff;font-weight:bold">private</span> <span style="color:#fff;font-weight:bold">static</span> <span style="color:#fff;font-weight:bold">final</span> <span style="color:#fff;font-weight:bold">class</span> Sync <span style="color:#fff;font-weight:bold">extends</span> AbstractQueuedSynchronizer {
    Sync(<span style="color:#fff;font-weight:bold">int</span> count) {
        <span style="color:#007f7f">// 这样就 state == count 了
</span><span style="color:#007f7f"></span>        setState(count);
    }
    ...
}
</code></pre></div><blockquote>
<p>代码都是套路，先分析套路：AQS 里面的 state 是一个整数值，这边用一个 int count 参数其实初始化就是设置了这个值，所有调用了 await 方法的等待线程会挂起，然后有其他一些线程会做 state = state - 1 操作，当 state 减到 0 的同时，那个将 state 减为 0 的线程会负责唤醒 所有调用了 await 方法的线程。都是套路啊，只是 Doug Lea 的套路很深，代码很巧妙，不然我们也没有要分析源码的必要。</p>
</blockquote>
<p>对于 CountDownLatch，我们仅仅需要关心两个方法，一个是 countDown() 方法，另一个是 await() 方法。</p>
<p>countDown() 方法每次调用都会将 state 减 1，直到 state 的值为 0；而 await 是一个阻塞方法，当 state 减为 0 的时候，await 方法才会返回。await 可以被多个线程调用，读者这个时候脑子里要有个图：所有调用了 await 方法的线程阻塞在 AQS 的阻塞队列中，等待条件满足（state == 0），将线程从队列中一个个唤醒过来。</p>
<p>我们用以下程序来分析源码，t1 和 t2 负责调用 countDown() 方法，t3 和 t4 调用 await 方法阻塞：</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#fff;font-weight:bold">public</span> <span style="color:#fff;font-weight:bold">class</span> CountDownLatchDemo {

    <span style="color:#fff;font-weight:bold">public</span> <span style="color:#fff;font-weight:bold">static</span> <span style="color:#fff;font-weight:bold">void</span> main(String[] args) {

        CountDownLatch latch = <span style="color:#fff;font-weight:bold">new</span> CountDownLatch(2);

        Thread t1 = <span style="color:#fff;font-weight:bold">new</span> Thread(<span style="color:#fff;font-weight:bold">new</span> Runnable() {
            @Override
            <span style="color:#fff;font-weight:bold">public</span> <span style="color:#fff;font-weight:bold">void</span> run() {
                <span style="color:#fff;font-weight:bold">try</span> {
                    Thread.<span style="color:#007f7f">sleep</span>(5000);
                } <span style="color:#fff;font-weight:bold">catch</span> (InterruptedException ignore) {
                }
                <span style="color:#007f7f">// 休息 5 秒后(模拟线程工作了 5 秒)，调用 countDown()
</span><span style="color:#007f7f"></span>                latch.<span style="color:#007f7f">countDown</span>();
            }
        }, <span style="color:#0ff;font-weight:bold">&#34;t1&#34;</span>);

        Thread t2 = <span style="color:#fff;font-weight:bold">new</span> Thread(<span style="color:#fff;font-weight:bold">new</span> Runnable() {
            @Override
            <span style="color:#fff;font-weight:bold">public</span> <span style="color:#fff;font-weight:bold">void</span> run() {
                <span style="color:#fff;font-weight:bold">try</span> {
                    Thread.<span style="color:#007f7f">sleep</span>(10000);
                } <span style="color:#fff;font-weight:bold">catch</span> (InterruptedException ignore) {
                }
                <span style="color:#007f7f">// 休息 10 秒后(模拟线程工作了 10 秒)，调用 countDown()
</span><span style="color:#007f7f"></span>                latch.<span style="color:#007f7f">countDown</span>();
            }
        }, <span style="color:#0ff;font-weight:bold">&#34;t2&#34;</span>);

        t1.<span style="color:#007f7f">start</span>();
        t2.<span style="color:#007f7f">start</span>();

        Thread t3 = <span style="color:#fff;font-weight:bold">new</span> Thread(<span style="color:#fff;font-weight:bold">new</span> Runnable() {
            @Override
            <span style="color:#fff;font-weight:bold">public</span> <span style="color:#fff;font-weight:bold">void</span> run() {
                <span style="color:#fff;font-weight:bold">try</span> {
                    <span style="color:#007f7f">// 阻塞，等待 state 减为 0
</span><span style="color:#007f7f"></span>                    latch.<span style="color:#007f7f">await</span>();
                    System.<span style="color:#007f7f">out</span>.<span style="color:#007f7f">println</span>(<span style="color:#0ff;font-weight:bold">&#34;线程 t3 从 await 中返回了&#34;</span>);
                } <span style="color:#fff;font-weight:bold">catch</span> (InterruptedException e) {
                    System.<span style="color:#007f7f">out</span>.<span style="color:#007f7f">println</span>(<span style="color:#0ff;font-weight:bold">&#34;线程 t3 await 被中断&#34;</span>);
                    Thread.<span style="color:#007f7f">currentThread</span>().<span style="color:#007f7f">interrupt</span>();
                }
            }
        }, <span style="color:#0ff;font-weight:bold">&#34;t3&#34;</span>);
        Thread t4 = <span style="color:#fff;font-weight:bold">new</span> Thread(<span style="color:#fff;font-weight:bold">new</span> Runnable() {
            @Override
            <span style="color:#fff;font-weight:bold">public</span> <span style="color:#fff;font-weight:bold">void</span> run() {
                <span style="color:#fff;font-weight:bold">try</span> {
                    <span style="color:#007f7f">// 阻塞，等待 state 减为 0
</span><span style="color:#007f7f"></span>                    latch.<span style="color:#007f7f">await</span>();
                    System.<span style="color:#007f7f">out</span>.<span style="color:#007f7f">println</span>(<span style="color:#0ff;font-weight:bold">&#34;线程 t4 从 await 中返回了&#34;</span>);
                } <span style="color:#fff;font-weight:bold">catch</span> (InterruptedException e) {
                    System.<span style="color:#007f7f">out</span>.<span style="color:#007f7f">println</span>(<span style="color:#0ff;font-weight:bold">&#34;线程 t4 await 被中断&#34;</span>);
                    Thread.<span style="color:#007f7f">currentThread</span>().<span style="color:#007f7f">interrupt</span>();
                }
            }
        }, <span style="color:#0ff;font-weight:bold">&#34;t4&#34;</span>);

        t3.<span style="color:#007f7f">start</span>();
        t4.<span style="color:#007f7f">start</span>();
    }
}
</code></pre></div><p>上述程序，大概在过了 10 秒左右的时候，会输出：</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">线程 t3 从 await 中返回了
线程 t4 从 await 中返回了
</code></pre></div><blockquote>
<p>这两条输出，顺序不是绝对的</p>
<p>后面的分析，我们假设 t3 先进入阻塞队列</p>
</blockquote>
<p>接下来，我们按照流程一步一步走：先 await 等待，然后被唤醒，await 方法返回。</p>
<p>首先，我们来看 await() 方法，它代表线程阻塞，等待 state 的值减为 0。</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#fff;font-weight:bold">public</span> <span style="color:#fff;font-weight:bold">void</span> await() <span style="color:#fff;font-weight:bold">throws</span> InterruptedException {
    sync.<span style="color:#007f7f">acquireSharedInterruptibly</span>(1);
}
<span style="color:#fff;font-weight:bold">public</span> <span style="color:#fff;font-weight:bold">final</span> <span style="color:#fff;font-weight:bold">void</span> acquireSharedInterruptibly(<span style="color:#fff;font-weight:bold">int</span> arg)
        <span style="color:#fff;font-weight:bold">throws</span> InterruptedException {
    <span style="color:#007f7f">// 这也是老套路了，我在第二篇的中断那一节说过了
</span><span style="color:#007f7f"></span>    <span style="color:#fff;font-weight:bold">if</span> (Thread.<span style="color:#007f7f">interrupted</span>())
        <span style="color:#fff;font-weight:bold">throw</span> <span style="color:#fff;font-weight:bold">new</span> InterruptedException();
    
    <span style="color:#007f7f">// t3 和 t4 调用 await 的时候，state 都大于 0（state 此时为 2）。
</span><span style="color:#007f7f"></span>    <span style="color:#007f7f">// 也就是说，这个 if 返回 true，然后往里看
</span><span style="color:#007f7f"></span>    <span style="color:#fff;font-weight:bold">if</span> (tryAcquireShared(arg) &lt; 0)
        doAcquireSharedInterruptibly(arg);
}
<span style="color:#007f7f">// 只有当 state == 0 的时候，这个方法才会返回 1
</span><span style="color:#007f7f"></span><span style="color:#fff;font-weight:bold">protected</span> <span style="color:#fff;font-weight:bold">int</span> tryAcquireShared(<span style="color:#fff;font-weight:bold">int</span> acquires) {
    <span style="color:#fff;font-weight:bold">return</span> (getState() == 0) ? 1 : -1;
}
</code></pre></div><p>从方法名我们就可以看出，这个方法是获取共享锁，并且此方法是可中断的（中断的时候抛出 InterruptedException 退出这个方法）。</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#fff;font-weight:bold">private</span> <span style="color:#fff;font-weight:bold">void</span> doAcquireSharedInterruptibly(<span style="color:#fff;font-weight:bold">int</span> arg)
    <span style="color:#fff;font-weight:bold">throws</span> InterruptedException {
    <span style="color:#007f7f">// 1. 入队
</span><span style="color:#007f7f"></span>    <span style="color:#fff;font-weight:bold">final</span> Node node = addWaiter(Node.<span style="color:#007f7f">SHARED</span>);
    <span style="color:#fff;font-weight:bold">boolean</span> failed = <span style="color:#fff;font-weight:bold">true</span>;
    <span style="color:#fff;font-weight:bold">try</span> {
        <span style="color:#fff;font-weight:bold">for</span> (;;) {
            <span style="color:#fff;font-weight:bold">final</span> Node p = node.<span style="color:#007f7f">predecessor</span>();
            <span style="color:#fff;font-weight:bold">if</span> (p == head) {
                <span style="color:#007f7f">// 同上，只要 state 不等于 0，那么这个方法返回 -1
</span><span style="color:#007f7f"></span>                <span style="color:#fff;font-weight:bold">int</span> r = tryAcquireShared(arg);
                <span style="color:#fff;font-weight:bold">if</span> (r &gt;= 0) {
                    setHeadAndPropagate(node, r);
                    p.<span style="color:#007f7f">next</span> = <span style="color:#fff;font-weight:bold">null</span>; <span style="color:#007f7f">// help GC
</span><span style="color:#007f7f"></span>                    failed = <span style="color:#fff;font-weight:bold">false</span>;
                    <span style="color:#fff;font-weight:bold">return</span>;
                }
            }
            <span style="color:#007f7f">// 2
</span><span style="color:#007f7f"></span>            <span style="color:#fff;font-weight:bold">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;
                parkAndCheckInterrupt())
                <span style="color:#fff;font-weight:bold">throw</span> <span style="color:#fff;font-weight:bold">new</span> InterruptedException();
        }
    } <span style="color:#fff;font-weight:bold">finally</span> {
        <span style="color:#fff;font-weight:bold">if</span> (failed)
            cancelAcquire(node);
    }
}
</code></pre></div><p>我们来仔细分析这个方法，线程 t3 经过第 1 步 addWaiter 入队以后，我们应该可以得到这个：</p>
<p><img src="http://img.zhouyi.tech/note/2-3314833503964de3be4271aca700df40.png" alt="2"></p>
<p>由于 tryAcquireShared 这个方法会返回 -1，所以 if (r &gt;= 0) 这个分支不会进去。到 shouldParkAfterFailedAcquire 的时候，t3 将 head 的 waitStatus 值设置为 -1，如下：</p>
<p><img src="http://img.zhouyi.tech/note/3-bc6f464c2a4e4fae875a9a88fddcc483.png" alt="3"></p>
<p>然后进入到 parkAndCheckInterrupt 的时候，t3 挂起。</p>
<p>我们再分析 t4 入队，t4 会将前驱节点 t3 所在节点的 waitStatus 设置为 -1，t4 入队后，应该是这样的：</p>
<p><img src="http://img.zhouyi.tech/note/4-ab6e4b820bc849329b537c5cd314424d.png" alt="4"></p>
<p>然后，t4 也挂起。接下来，t3 和 t4 就等待唤醒了。</p>
<p>接下来，我们来看唤醒的流程。为了让下面的示意图更丰富些，我们假设用 10 初始化 CountDownLatch。</p>
<p><img src="http://img.zhouyi.tech/note/1-4b714d053fca4cab9cf602cb70849c60.png" alt="1"></p>
<p>当然，我们的例子中，其实没有 10 个线程，只有 2 个线程 t1 和 t2，只是为了让图好看些罢了。</p>
<p>我们再一步步看具体的流程。首先，我们看 countDown() 方法:</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#fff;font-weight:bold">public</span> <span style="color:#fff;font-weight:bold">void</span> countDown() {
    sync.<span style="color:#007f7f">releaseShared</span>(1);
}
<span style="color:#fff;font-weight:bold">public</span> <span style="color:#fff;font-weight:bold">final</span> <span style="color:#fff;font-weight:bold">boolean</span> releaseShared(<span style="color:#fff;font-weight:bold">int</span> arg) {
    <span style="color:#007f7f">// 只有当 state 减为 0 的时候，tryReleaseShared 才返回 true
</span><span style="color:#007f7f"></span>    <span style="color:#007f7f">// 否则只是简单的 state = state - 1 那么 countDown() 方法就结束了
</span><span style="color:#007f7f"></span>    <span style="color:#007f7f">//    将 state 减到 0 的那个操作才是最复杂的，继续往下吧
</span><span style="color:#007f7f"></span>    <span style="color:#fff;font-weight:bold">if</span> (tryReleaseShared(arg)) {
        <span style="color:#007f7f">// 唤醒 await 的线程
</span><span style="color:#007f7f"></span>        doReleaseShared();
        <span style="color:#fff;font-weight:bold">return</span> <span style="color:#fff;font-weight:bold">true</span>;
    }
    <span style="color:#fff;font-weight:bold">return</span> <span style="color:#fff;font-weight:bold">false</span>;
}
<span style="color:#007f7f">// 这个方法很简单，用自旋的方法实现 state 减 1
</span><span style="color:#007f7f"></span><span style="color:#fff;font-weight:bold">protected</span> <span style="color:#fff;font-weight:bold">boolean</span> tryReleaseShared(<span style="color:#fff;font-weight:bold">int</span> releases) {
    <span style="color:#fff;font-weight:bold">for</span> (;;) {
        <span style="color:#fff;font-weight:bold">int</span> c = getState();
        <span style="color:#fff;font-weight:bold">if</span> (c == 0)
            <span style="color:#fff;font-weight:bold">return</span> <span style="color:#fff;font-weight:bold">false</span>;
        <span style="color:#fff;font-weight:bold">int</span> nextc = c-1;
        <span style="color:#fff;font-weight:bold">if</span> (compareAndSetState(c, nextc))
            <span style="color:#fff;font-weight:bold">return</span> nextc == 0;
    }
}
</code></pre></div><p>countDown 方法就是每次调用都将 state 值减 1，如果 state 减到 0 了，那么就调用下面的方法进行唤醒阻塞队列中的线程：</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#007f7f">// 调用这个方法的时候，state == 0
</span><span style="color:#007f7f">// 这个方法先不要看所有的代码，按照思路往下到我写注释的地方，我们先跑通一个流程，其他的之后还会仔细分析
</span><span style="color:#007f7f"></span><span style="color:#fff;font-weight:bold">private</span> <span style="color:#fff;font-weight:bold">void</span> doReleaseShared() {
    <span style="color:#fff;font-weight:bold">for</span> (;;) {
        Node h = head;
        <span style="color:#fff;font-weight:bold">if</span> (h != <span style="color:#fff;font-weight:bold">null</span> &amp;&amp; h != tail) {
            <span style="color:#fff;font-weight:bold">int</span> ws = h.<span style="color:#007f7f">waitStatus</span>;
            <span style="color:#007f7f">// t3 入队的时候，已经将头节点的 waitStatus 设置为 Node.SIGNAL（-1） 了
</span><span style="color:#007f7f"></span>            <span style="color:#fff;font-weight:bold">if</span> (ws == Node.<span style="color:#007f7f">SIGNAL</span>) {
                <span style="color:#007f7f">// 将 head 的 waitStatue 设置为 0
</span><span style="color:#007f7f"></span>                <span style="color:#fff;font-weight:bold">if</span> (!compareAndSetWaitStatus(h, Node.<span style="color:#007f7f">SIGNAL</span>, 0))
                    <span style="color:#fff;font-weight:bold">continue</span>;            <span style="color:#007f7f">// loop to recheck cases
</span><span style="color:#007f7f"></span>                <span style="color:#007f7f">// 就是这里，唤醒 head 的后继节点，也就是阻塞队列中的第一个节点
</span><span style="color:#007f7f"></span>                <span style="color:#007f7f">// 在这里，也就是唤醒 t3
</span><span style="color:#007f7f"></span>                unparkSuccessor(h);
            }
            <span style="color:#fff;font-weight:bold">else</span> <span style="color:#fff;font-weight:bold">if</span> (ws == 0 &amp;&amp;
                     !compareAndSetWaitStatus(h, 0, Node.<span style="color:#007f7f">PROPAGATE</span>)) <span style="color:#007f7f">// todo
</span><span style="color:#007f7f"></span>                <span style="color:#fff;font-weight:bold">continue</span>;                <span style="color:#007f7f">// loop on failed CAS
</span><span style="color:#007f7f"></span>        }
        <span style="color:#fff;font-weight:bold">if</span> (h == head)                   <span style="color:#007f7f">// loop if head changed
</span><span style="color:#007f7f"></span>            <span style="color:#fff;font-weight:bold">break</span>;
    }
}
</code></pre></div><p>一旦 t3 被唤醒后，我们继续回到 await 的这段代码，parkAndCheckInterrupt 返回，我们先不考虑中断的情况：</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#fff;font-weight:bold">private</span> <span style="color:#fff;font-weight:bold">void</span> doAcquireSharedInterruptibly(<span style="color:#fff;font-weight:bold">int</span> arg)
    <span style="color:#fff;font-weight:bold">throws</span> InterruptedException {
    <span style="color:#fff;font-weight:bold">final</span> Node node = addWaiter(Node.<span style="color:#007f7f">SHARED</span>);
    <span style="color:#fff;font-weight:bold">boolean</span> failed = <span style="color:#fff;font-weight:bold">true</span>;
    <span style="color:#fff;font-weight:bold">try</span> {
        <span style="color:#fff;font-weight:bold">for</span> (;;) {
            <span style="color:#fff;font-weight:bold">final</span> Node p = node.<span style="color:#007f7f">predecessor</span>();
            <span style="color:#fff;font-weight:bold">if</span> (p == head) {
                <span style="color:#fff;font-weight:bold">int</span> r = tryAcquireShared(arg);
                <span style="color:#fff;font-weight:bold">if</span> (r &gt;= 0) {
                    setHeadAndPropagate(node, r); <span style="color:#007f7f">// 2. 这里是下一步
</span><span style="color:#007f7f"></span>                    p.<span style="color:#007f7f">next</span> = <span style="color:#fff;font-weight:bold">null</span>; <span style="color:#007f7f">// help GC
</span><span style="color:#007f7f"></span>                    failed = <span style="color:#fff;font-weight:bold">false</span>;
                    <span style="color:#fff;font-weight:bold">return</span>;
                }
            }
            <span style="color:#fff;font-weight:bold">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;
                <span style="color:#007f7f">// 1. 唤醒后这个方法返回
</span><span style="color:#007f7f"></span>                parkAndCheckInterrupt())
                <span style="color:#fff;font-weight:bold">throw</span> <span style="color:#fff;font-weight:bold">new</span> InterruptedException();
        }
    } <span style="color:#fff;font-weight:bold">finally</span> {
        <span style="color:#fff;font-weight:bold">if</span> (failed)
            cancelAcquire(node);
    }
}
</code></pre></div><p>接下来，t3 会进到 setHeadAndPropagate(node, r) 这个方法，先把 head 给占了，然后唤醒队列中其他的线程：</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#fff;font-weight:bold">private</span> <span style="color:#fff;font-weight:bold">void</span> setHeadAndPropagate(Node node, <span style="color:#fff;font-weight:bold">int</span> propagate) {
    Node h = head; <span style="color:#007f7f">// Record old head for check below
</span><span style="color:#007f7f"></span>    setHead(node);
  
    <span style="color:#007f7f">// 下面说的是，唤醒当前 node 之后的节点，即 t3 已经醒了，马上唤醒 t4
</span><span style="color:#007f7f"></span>    <span style="color:#007f7f">// 类似的，如果 t4 后面还有 t5，那么 t4 醒了以后，马上将 t5 给唤醒了
</span><span style="color:#007f7f"></span>    <span style="color:#fff;font-weight:bold">if</span> (propagate &gt; 0 || h == <span style="color:#fff;font-weight:bold">null</span> || h.<span style="color:#007f7f">waitStatus</span> &lt; 0 ||
        (h = head) == <span style="color:#fff;font-weight:bold">null</span> || h.<span style="color:#007f7f">waitStatus</span> &lt; 0) {
        Node s = node.<span style="color:#007f7f">next</span>;
        <span style="color:#fff;font-weight:bold">if</span> (s == <span style="color:#fff;font-weight:bold">null</span> || s.<span style="color:#007f7f">isShared</span>())
            <span style="color:#007f7f">// 又是这个方法，只是现在的 head 已经不是原来的空节点了，是 t3 的节点了
</span><span style="color:#007f7f"></span>            doReleaseShared();
    }
}
</code></pre></div><p>又回到这个方法了，那么接下来，我们好好分析 doReleaseShared 这个方法，我们根据流程，头节点 head 此时是 t3 节点了：</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#007f7f">// 调用这个方法的时候，state == 0
</span><span style="color:#007f7f"></span><span style="color:#fff;font-weight:bold">private</span> <span style="color:#fff;font-weight:bold">void</span> doReleaseShared() {
    <span style="color:#fff;font-weight:bold">for</span> (;;) {
        Node h = head;
        <span style="color:#007f7f">// 1. h == null: 说明阻塞队列为空
</span><span style="color:#007f7f"></span>        <span style="color:#007f7f">// 2. h == tail: 说明头结点可能是刚刚初始化的头节点，
</span><span style="color:#007f7f"></span>        <span style="color:#007f7f">//   或者是普通线程节点，但是此节点既然是头节点了，那么代表已经被唤醒了，阻塞队列没有其他节点了
</span><span style="color:#007f7f"></span>        <span style="color:#007f7f">// 所以这两种情况不需要进行唤醒后继节点
</span><span style="color:#007f7f"></span>        <span style="color:#fff;font-weight:bold">if</span> (h != <span style="color:#fff;font-weight:bold">null</span> &amp;&amp; h != tail) {
            <span style="color:#fff;font-weight:bold">int</span> ws = h.<span style="color:#007f7f">waitStatus</span>;
            <span style="color:#007f7f">// t4 将头节点(此时是 t3)的 waitStatus 设置为 Node.SIGNAL（-1） 了
</span><span style="color:#007f7f"></span>            <span style="color:#fff;font-weight:bold">if</span> (ws == Node.<span style="color:#007f7f">SIGNAL</span>) {
                <span style="color:#007f7f">// 这里 CAS 失败的场景请看下面的解读
</span><span style="color:#007f7f"></span>                <span style="color:#fff;font-weight:bold">if</span> (!compareAndSetWaitStatus(h, Node.<span style="color:#007f7f">SIGNAL</span>, 0))
                    <span style="color:#fff;font-weight:bold">continue</span>;            <span style="color:#007f7f">// loop to recheck cases
</span><span style="color:#007f7f"></span>                <span style="color:#007f7f">// 就是这里，唤醒 head 的后继节点，也就是阻塞队列中的第一个节点
</span><span style="color:#007f7f"></span>                <span style="color:#007f7f">// 在这里，也就是唤醒 t4
</span><span style="color:#007f7f"></span>                unparkSuccessor(h);
            }
            <span style="color:#fff;font-weight:bold">else</span> <span style="color:#fff;font-weight:bold">if</span> (ws == 0 &amp;&amp;
                     <span style="color:#007f7f">// 这个 CAS 失败的场景是：执行到这里的时候，刚好有一个节点入队，入队会将这个 ws 设置为 -1
</span><span style="color:#007f7f"></span>                     !compareAndSetWaitStatus(h, 0, Node.<span style="color:#007f7f">PROPAGATE</span>))
                <span style="color:#fff;font-weight:bold">continue</span>;                <span style="color:#007f7f">// loop on failed CAS
</span><span style="color:#007f7f"></span>        }
        <span style="color:#007f7f">// 如果到这里的时候，前面唤醒的线程已经占领了 head，那么再循环
</span><span style="color:#007f7f"></span>        <span style="color:#007f7f">// 否则，就是 head 没变，那么退出循环，
</span><span style="color:#007f7f"></span>        <span style="color:#007f7f">// 退出循环是不是意味着阻塞队列中的其他节点就不唤醒了？当然不是，唤醒的线程之后还是会调用这个方法的
</span><span style="color:#007f7f"></span>        <span style="color:#fff;font-weight:bold">if</span> (h == head)                   <span style="color:#007f7f">// loop if head changed
</span><span style="color:#007f7f"></span>            <span style="color:#fff;font-weight:bold">break</span>;
    }
}
</code></pre></div><p>我们分析下最后一个 if 语句，然后才能解释第一个 CAS 为什么可能会失败：</p>
<ol>
<li>h == head：说明头节点还没有被刚刚用 unparkSuccessor 唤醒的线程（这里可以理解为 t4）占有，此时 break 退出循环。</li>
<li>h != head：头节点被刚刚唤醒的线程（这里可以理解为 t4）占有，那么这里重新进入下一轮循环，唤醒下一个节点（这里是 t4 ）。我们知道，等到 t4 被唤醒后，其实是会主动唤醒 t5、t6、t7&hellip;，那为什么这里要进行下一个循环来唤醒 t5 呢？我觉得是出于吞吐量的考虑。</li>
</ol>
<p>满足上面的 2 的场景，那么我们就能知道为什么上面的 CAS 操作 compareAndSetWaitStatus(h, Node.SIGNAL, 0) 会失败了？</p>
<p>因为当前进行 for 循环的线程到这里的时候，可能刚刚唤醒的线程 t4 也刚刚好到这里了，那么就有可能 CAS 失败了。</p>
<p>for 循环第一轮的时候会唤醒 t4，t4 醒后会将自己设置为头节点，如果在 t4 设置头节点后，for 循环才跑到 if (h == head)，那么此时会返回 false，for 循环会进入下一轮。t4 唤醒后也会进入到这个方法里面，那么 for 循环第二轮和 t4 就有可能在这个 CAS 相遇，那么就只会有一个成功了。</p>
<h2 id="cyclicbarrier">CyclicBarrier</h2>
<p>字面意思是“可重复使用的栅栏”或“周期性的栅栏”，总之不是用了一次就没用了的，CyclicBarrier 相比 CountDownLatch 来说，要简单很多，其源码没有什么高深的地方，它是 ReentrantLock 和 Condition 的组合使用。看如下示意图，CyclicBarrier 和 CountDownLatch 是不是很像，只是 CyclicBarrier 可以有不止一个栅栏，因为它的栅栏（Barrier）可以重复使用（Cyclic）。</p>
<p><img src="http://img.zhouyi.tech/note/cyclicbarrier-2-04d9642801d34f729949ff1db7994d40.png" alt="cyclicbarrier-2"></p>
<p>首先，CyclicBarrier 的源码实现和 CountDownLatch 大相径庭，CountDownLatch 基于 AQS 的共享模式的使用，而 CyclicBarrier 基于 Condition 来实现。</p>
<p>因为 CyclicBarrier 的源码相对来说简单许多，读者只要熟悉了前面关于 Condition 的分析，那么这里的源码是毫无压力的，就是几个特殊概念罢了。</p>
<p>先用一张图来描绘下 CyclicBarrier 里面的一些概念，和它的基本使用流程：</p>
<p><img src="http://img.zhouyi.tech/note/cyclicbarrier-3-85a8e05519f544329419e3db2ad57392.png" alt="cyclicbarrier-3"></p>
<blockquote>
<p>看图我们也知道了，CyclicBarrier 的源码最重要的就是 await() 方法了。</p>
</blockquote>
<p>大家先把图看完，然后我们开始源码分析：</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#fff;font-weight:bold">public</span> <span style="color:#fff;font-weight:bold">class</span> CyclicBarrier {
    <span style="color:#007f7f">// 我们说了，CyclicBarrier 是可以重复使用的，我们把每次从开始使用到穿过栅栏当做&#34;一代&#34;，或者&#34;一个周期&#34;
</span><span style="color:#007f7f"></span>    <span style="color:#fff;font-weight:bold">private</span> <span style="color:#fff;font-weight:bold">static</span> <span style="color:#fff;font-weight:bold">class</span> Generation {
        <span style="color:#fff;font-weight:bold">boolean</span> broken = <span style="color:#fff;font-weight:bold">false</span>;
    }

    <span style="color:#007f7f">/** The lock for guarding barrier entry */</span>
    <span style="color:#fff;font-weight:bold">private</span> <span style="color:#fff;font-weight:bold">final</span> ReentrantLock lock = <span style="color:#fff;font-weight:bold">new</span> ReentrantLock();
    
    <span style="color:#007f7f">// CyclicBarrier 是基于 Condition 的
</span><span style="color:#007f7f"></span>    <span style="color:#007f7f">// Condition 是“条件”的意思，CyclicBarrier 的等待线程通过 barrier 的“条件”是大家都到了栅栏上
</span><span style="color:#007f7f"></span>    <span style="color:#fff;font-weight:bold">private</span> <span style="color:#fff;font-weight:bold">final</span> Condition trip = lock.<span style="color:#007f7f">newCondition</span>();

    <span style="color:#007f7f">// 参与的线程数
</span><span style="color:#007f7f"></span>    <span style="color:#fff;font-weight:bold">private</span> <span style="color:#fff;font-weight:bold">final</span> <span style="color:#fff;font-weight:bold">int</span> parties;

    <span style="color:#007f7f">// 如果设置了这个，代表越过栅栏之前，要执行相应的操作
</span><span style="color:#007f7f"></span>    <span style="color:#fff;font-weight:bold">private</span> <span style="color:#fff;font-weight:bold">final</span> Runnable barrierCommand;

    <span style="color:#007f7f">// 当前所处的“代”
</span><span style="color:#007f7f"></span>    <span style="color:#fff;font-weight:bold">private</span> Generation generation = <span style="color:#fff;font-weight:bold">new</span> Generation();

    <span style="color:#007f7f">// 还没有到栅栏的线程数，这个值初始为 parties，然后递减
</span><span style="color:#007f7f"></span>    <span style="color:#007f7f">// 还没有到栅栏的线程数 = parties - 已经到栅栏的数量
</span><span style="color:#007f7f"></span>    <span style="color:#fff;font-weight:bold">private</span> <span style="color:#fff;font-weight:bold">int</span> count;
  
    <span style="color:#fff;font-weight:bold">public</span> CyclicBarrier(<span style="color:#fff;font-weight:bold">int</span> parties, Runnable barrierAction) {
        <span style="color:#fff;font-weight:bold">if</span> (parties &lt;= 0) <span style="color:#fff;font-weight:bold">throw</span> <span style="color:#fff;font-weight:bold">new</span> IllegalArgumentException();
        <span style="color:#fff;font-weight:bold">this</span>.<span style="color:#007f7f">parties</span> = parties;
        <span style="color:#fff;font-weight:bold">this</span>.<span style="color:#007f7f">count</span> = parties;
        <span style="color:#fff;font-weight:bold">this</span>.<span style="color:#007f7f">barrierCommand</span> = barrierAction;
    }

    <span style="color:#fff;font-weight:bold">public</span> CyclicBarrier(<span style="color:#fff;font-weight:bold">int</span> parties) {
        <span style="color:#fff;font-weight:bold">this</span>(parties, <span style="color:#fff;font-weight:bold">null</span>);
    }
</code></pre></div><p>首先，先看怎么开启新的一代：</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#007f7f">// 开启新的一代，当最后一个线程到达栅栏上的时候，调用这个方法来唤醒其他线程，同时初始化“下一代”
</span><span style="color:#007f7f"></span><span style="color:#fff;font-weight:bold">private</span> <span style="color:#fff;font-weight:bold">void</span> nextGeneration() {
    <span style="color:#007f7f">// 首先，需要唤醒所有的在栅栏上等待的线程
</span><span style="color:#007f7f"></span>    trip.<span style="color:#007f7f">signalAll</span>();
    <span style="color:#007f7f">// 更新 count 的值
</span><span style="color:#007f7f"></span>    count = parties;
    <span style="color:#007f7f">// 重新生成“新一代”
</span><span style="color:#007f7f"></span>    generation = <span style="color:#fff;font-weight:bold">new</span> Generation();
}
</code></pre></div><blockquote>
<p>开启新的一代，类似于重新实例化一个 CyclicBarrier 实例</p>
</blockquote>
<p>看看怎么打破一个栅栏：</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#fff;font-weight:bold">private</span> <span style="color:#fff;font-weight:bold">void</span> breakBarrier() {
    <span style="color:#007f7f">// 设置状态 broken 为 true
</span><span style="color:#007f7f"></span>    generation.<span style="color:#007f7f">broken</span> = <span style="color:#fff;font-weight:bold">true</span>;
    <span style="color:#007f7f">// 重置 count 为初始值 parties
</span><span style="color:#007f7f"></span>    count = parties;
    <span style="color:#007f7f">// 唤醒所有已经在等待的线程
</span><span style="color:#007f7f"></span>    trip.<span style="color:#007f7f">signalAll</span>();
}
</code></pre></div><p>这两个方法之后用得到，现在开始分析最重要的等待通过栅栏方法 await 方法：</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#007f7f">// 不带超时机制
</span><span style="color:#007f7f"></span><span style="color:#fff;font-weight:bold">public</span> <span style="color:#fff;font-weight:bold">int</span> await() <span style="color:#fff;font-weight:bold">throws</span> InterruptedException, BrokenBarrierException {
    <span style="color:#fff;font-weight:bold">try</span> {
        <span style="color:#fff;font-weight:bold">return</span> dowait(<span style="color:#fff;font-weight:bold">false</span>, 0L);
    } <span style="color:#fff;font-weight:bold">catch</span> (TimeoutException toe) {
        <span style="color:#fff;font-weight:bold">throw</span> <span style="color:#fff;font-weight:bold">new</span> Error(toe); <span style="color:#007f7f">// cannot happen
</span><span style="color:#007f7f"></span>    }
}
<span style="color:#007f7f">// 带超时机制，如果超时抛出 TimeoutException 异常
</span><span style="color:#007f7f"></span><span style="color:#fff;font-weight:bold">public</span> <span style="color:#fff;font-weight:bold">int</span> await(<span style="color:#fff;font-weight:bold">long</span> timeout, TimeUnit unit)
    <span style="color:#fff;font-weight:bold">throws</span> InterruptedException,
           BrokenBarrierException,
           TimeoutException {
    <span style="color:#fff;font-weight:bold">return</span> dowait(<span style="color:#fff;font-weight:bold">true</span>, unit.<span style="color:#007f7f">toNanos</span>(timeout));
}
</code></pre></div><p>继续往里看：</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#fff;font-weight:bold">private</span> <span style="color:#fff;font-weight:bold">int</span> dowait(<span style="color:#fff;font-weight:bold">boolean</span> timed, <span style="color:#fff;font-weight:bold">long</span> nanos)
        <span style="color:#fff;font-weight:bold">throws</span> InterruptedException, BrokenBarrierException,
               TimeoutException {
    <span style="color:#fff;font-weight:bold">final</span> ReentrantLock lock = <span style="color:#fff;font-weight:bold">this</span>.<span style="color:#007f7f">lock</span>;
    <span style="color:#007f7f">// 先要获取到锁，然后在 finally 中要记得释放锁
</span><span style="color:#007f7f"></span>    <span style="color:#007f7f">// 如果记得 Condition 部分的话，我们知道 condition 的 await() 会释放锁，被 signal() 唤醒的时候需要重新获取锁
</span><span style="color:#007f7f"></span>    lock.<span style="color:#007f7f">lock</span>();
    <span style="color:#fff;font-weight:bold">try</span> {
        <span style="color:#fff;font-weight:bold">final</span> Generation g = generation;
        <span style="color:#007f7f">// 检查栅栏是否被打破，如果被打破，抛出 BrokenBarrierException 异常
</span><span style="color:#007f7f"></span>        <span style="color:#fff;font-weight:bold">if</span> (g.<span style="color:#007f7f">broken</span>)
            <span style="color:#fff;font-weight:bold">throw</span> <span style="color:#fff;font-weight:bold">new</span> BrokenBarrierException();
        <span style="color:#007f7f">// 检查中断状态，如果中断了，抛出 InterruptedException 异常
</span><span style="color:#007f7f"></span>        <span style="color:#fff;font-weight:bold">if</span> (Thread.<span style="color:#007f7f">interrupted</span>()) {
            breakBarrier();
            <span style="color:#fff;font-weight:bold">throw</span> <span style="color:#fff;font-weight:bold">new</span> InterruptedException();
        }
        <span style="color:#007f7f">// index 是这个 await 方法的返回值
</span><span style="color:#007f7f"></span>        <span style="color:#007f7f">// 注意到这里，这个是从 count 递减后得到的值
</span><span style="color:#007f7f"></span>        <span style="color:#fff;font-weight:bold">int</span> index = --count;
      
        <span style="color:#007f7f">// 如果等于 0，说明所有的线程都到栅栏上了，准备通过
</span><span style="color:#007f7f"></span>        <span style="color:#fff;font-weight:bold">if</span> (index == 0) {  <span style="color:#007f7f">// tripped
</span><span style="color:#007f7f"></span>            <span style="color:#fff;font-weight:bold">boolean</span> ranAction = <span style="color:#fff;font-weight:bold">false</span>;
            <span style="color:#fff;font-weight:bold">try</span> {
                <span style="color:#007f7f">// 如果在初始化的时候，指定了通过栅栏前需要执行的操作，在这里会得到执行
</span><span style="color:#007f7f"></span>                <span style="color:#fff;font-weight:bold">final</span> Runnable command = barrierCommand;
                <span style="color:#fff;font-weight:bold">if</span> (command != <span style="color:#fff;font-weight:bold">null</span>)
                    command.<span style="color:#007f7f">run</span>();
                <span style="color:#007f7f">// 如果 ranAction 为 true，说明执行 command.run() 的时候，没有发生异常退出的情况
</span><span style="color:#007f7f"></span>                ranAction = <span style="color:#fff;font-weight:bold">true</span>;
                <span style="color:#007f7f">// 唤醒等待的线程，然后开启新的一代
</span><span style="color:#007f7f"></span>                nextGeneration();
                <span style="color:#fff;font-weight:bold">return</span> 0;
            } <span style="color:#fff;font-weight:bold">finally</span> {
                <span style="color:#fff;font-weight:bold">if</span> (!ranAction)
                    <span style="color:#007f7f">// 进到这里，说明执行指定操作的时候，发生了异常，那么需要打破栅栏
</span><span style="color:#007f7f"></span>                    <span style="color:#007f7f">// 之前我们说了，打破栅栏意味着唤醒所有等待的线程，设置 broken 为 true，重置 count 为 parties
</span><span style="color:#007f7f"></span>                    breakBarrier();
            }
        }

        <span style="color:#007f7f">// loop until tripped, broken, interrupted, or timed out
</span><span style="color:#007f7f"></span>        <span style="color:#007f7f">// 如果是最后一个线程调用 await，那么上面就返回了
</span><span style="color:#007f7f"></span>        <span style="color:#007f7f">// 下面的操作是给那些不是最后一个到达栅栏的线程执行的
</span><span style="color:#007f7f"></span>        <span style="color:#fff;font-weight:bold">for</span> (;;) {
            <span style="color:#fff;font-weight:bold">try</span> {
                <span style="color:#007f7f">// 如果带有超时机制，调用带超时的 Condition 的 await 方法等待，直到最后一个线程调用 await
</span><span style="color:#007f7f"></span>                <span style="color:#fff;font-weight:bold">if</span> (!timed)
                    trip.<span style="color:#007f7f">await</span>();
                <span style="color:#fff;font-weight:bold">else</span> <span style="color:#fff;font-weight:bold">if</span> (nanos &gt; 0L)
                    nanos = trip.<span style="color:#007f7f">awaitNanos</span>(nanos);
            } <span style="color:#fff;font-weight:bold">catch</span> (InterruptedException ie) {
                <span style="color:#007f7f">// 如果到这里，说明等待的线程在 await（是 Condition 的 await）的时候被中断
</span><span style="color:#007f7f"></span>                <span style="color:#fff;font-weight:bold">if</span> (g == generation &amp;&amp; ! g.<span style="color:#007f7f">broken</span>) {
                    <span style="color:#007f7f">// 打破栅栏
</span><span style="color:#007f7f"></span>                    breakBarrier();
                    <span style="color:#007f7f">// 打破栅栏后，重新抛出这个 InterruptedException 异常给外层调用的方法
</span><span style="color:#007f7f"></span>                    <span style="color:#fff;font-weight:bold">throw</span> ie;
                } <span style="color:#fff;font-weight:bold">else</span> {
                    <span style="color:#007f7f">// 到这里，说明 g != generation, 说明新的一代已经产生，即最后一个线程 await 执行完成，
</span><span style="color:#007f7f"></span>                    <span style="color:#007f7f">// 那么此时没有必要再抛出 InterruptedException 异常，记录下来这个中断信息即可
</span><span style="color:#007f7f"></span>                    <span style="color:#007f7f">// 或者是栅栏已经被打破了，那么也不应该抛出 InterruptedException 异常，
</span><span style="color:#007f7f"></span>                    <span style="color:#007f7f">// 而是之后抛出 BrokenBarrierException 异常
</span><span style="color:#007f7f"></span>                    Thread.<span style="color:#007f7f">currentThread</span>().<span style="color:#007f7f">interrupt</span>();
                }
            }

          	<span style="color:#007f7f">// 唤醒后，检查栅栏是否是“破的”
</span><span style="color:#007f7f"></span>            <span style="color:#fff;font-weight:bold">if</span> (g.<span style="color:#007f7f">broken</span>)
                <span style="color:#fff;font-weight:bold">throw</span> <span style="color:#fff;font-weight:bold">new</span> BrokenBarrierException();

            <span style="color:#007f7f">// 这个 for 循环除了异常，就是要从这里退出了
</span><span style="color:#007f7f"></span>            <span style="color:#007f7f">// 我们要清楚，最后一个线程在执行完指定任务(如果有的话)，会调用 nextGeneration 来开启一个新的代
</span><span style="color:#007f7f"></span>            <span style="color:#007f7f">// 然后释放掉锁，其他线程从 Condition 的 await 方法中得到锁并返回，然后到这里的时候，其实就会满足 g != generation 的
</span><span style="color:#007f7f"></span>            <span style="color:#007f7f">// 那什么时候不满足呢？barrierCommand 执行过程中抛出了异常，那么会执行打破栅栏操作，
</span><span style="color:#007f7f"></span>            <span style="color:#007f7f">// 设置 broken 为true，然后唤醒这些线程。这些线程会从上面的 if (g.broken) 这个分支抛 BrokenBarrierException 异常返回
</span><span style="color:#007f7f"></span>            <span style="color:#007f7f">// 当然，还有最后一种可能，那就是 await 超时，此种情况不会从上面的 if 分支异常返回，也不会从这里返回，会执行后面的代码
</span><span style="color:#007f7f"></span>            <span style="color:#fff;font-weight:bold">if</span> (g != generation)
                <span style="color:#fff;font-weight:bold">return</span> index;

            <span style="color:#007f7f">// 如果醒来发现超时了，打破栅栏，抛出异常
</span><span style="color:#007f7f"></span>            <span style="color:#fff;font-weight:bold">if</span> (timed &amp;&amp; nanos &lt;= 0L) {
                breakBarrier();
                <span style="color:#fff;font-weight:bold">throw</span> <span style="color:#fff;font-weight:bold">new</span> TimeoutException();
            }
        }
    } <span style="color:#fff;font-weight:bold">finally</span> {
        lock.<span style="color:#007f7f">unlock</span>();
    }
}
</code></pre></div><p>好了，我想我应该讲清楚了吧，我好像几乎没有漏掉任何一行代码吧？</p>
<p>下面开始收尾工作。</p>
<p>首先，我们看看怎么得到有多少个线程到了栅栏上，处于等待状态：</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#fff;font-weight:bold">public</span> <span style="color:#fff;font-weight:bold">int</span> getNumberWaiting() {
    <span style="color:#fff;font-weight:bold">final</span> ReentrantLock lock = <span style="color:#fff;font-weight:bold">this</span>.<span style="color:#007f7f">lock</span>;
    lock.<span style="color:#007f7f">lock</span>();
    <span style="color:#fff;font-weight:bold">try</span> {
        <span style="color:#fff;font-weight:bold">return</span> parties - count;
    } <span style="color:#fff;font-weight:bold">finally</span> {
        lock.<span style="color:#007f7f">unlock</span>();
    }
}
</code></pre></div><p>判断一个栅栏是否被打破了，这个很简单，直接看 broken 的值即可：</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#fff;font-weight:bold">public</span> <span style="color:#fff;font-weight:bold">boolean</span> isBroken() {
    <span style="color:#fff;font-weight:bold">final</span> ReentrantLock lock = <span style="color:#fff;font-weight:bold">this</span>.<span style="color:#007f7f">lock</span>;
    lock.<span style="color:#007f7f">lock</span>();
    <span style="color:#fff;font-weight:bold">try</span> {
        <span style="color:#fff;font-weight:bold">return</span> generation.<span style="color:#007f7f">broken</span>;
    } <span style="color:#fff;font-weight:bold">finally</span> {
        lock.<span style="color:#007f7f">unlock</span>();
    }
}
</code></pre></div><p>前面我们在说 await 的时候也几乎说清楚了，什么时候栅栏会被打破，总结如下：</p>
<ol>
<li>中断，我们说了，如果某个等待的线程发生了中断，那么会打破栅栏，同时抛出 InterruptedException 异常；</li>
<li>超时，打破栅栏，同时抛出 TimeoutException 异常；</li>
<li>指定执行的操作抛出了异常，这个我们前面也说过。</li>
</ol>
<p>最后，我们来看看怎么重置一个栅栏：</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#fff;font-weight:bold">public</span> <span style="color:#fff;font-weight:bold">void</span> reset() {
    <span style="color:#fff;font-weight:bold">final</span> ReentrantLock lock = <span style="color:#fff;font-weight:bold">this</span>.<span style="color:#007f7f">lock</span>;
    lock.<span style="color:#007f7f">lock</span>();
    <span style="color:#fff;font-weight:bold">try</span> {
        breakBarrier();   <span style="color:#007f7f">// break the current generation
</span><span style="color:#007f7f"></span>        nextGeneration(); <span style="color:#007f7f">// start a new generation
</span><span style="color:#007f7f"></span>    } <span style="color:#fff;font-weight:bold">finally</span> {
        lock.<span style="color:#007f7f">unlock</span>();
    }
}
</code></pre></div><p>我们设想一下，如果初始化时，指定了线程 parties = 4，前面有 3 个线程调用了 await 等待，在第 4 个线程调用 await 之前，我们调用 reset 方法，那么会发生什么？</p>
<p>首先，打破栅栏，那意味着所有等待的线程（3个等待的线程）会唤醒，await 方法会通过抛出 BrokenBarrierException 异常返回。然后开启新的一代，重置了 count 和 generation，相当于一切归零了。</p>
<p>怎么样，CyclicBarrier 源码很简单吧。</p>
<h2 id="semaphore">Semaphore</h2>
<p>有了 CountDownLatch 的基础后，分析 Semaphore 会简单很多。Semaphore 是什么呢？它类似一个资源池（读者可以类比线程池），每个线程需要调用 acquire() 方法获取资源，然后才能执行，执行完后，需要 release 资源，让给其他的线程用。</p>
<p>大概大家也可以猜到，Semaphore 其实也是 AQS 中共享锁的使用，因为每个线程共享一个池嘛。</p>
<p>套路解读：创建 Semaphore 实例的时候，需要一个参数 permits，这个基本上可以确定是设置给 AQS 的 state 的，然后每个线程调用 acquire 的时候，执行 state = state - 1，release 的时候执行 state = state + 1，当然，acquire  的时候，如果 state = 0，说明没有资源了，需要等待其他线程 release。</p>
<p>构造方法：</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#fff;font-weight:bold">public</span> Semaphore(<span style="color:#fff;font-weight:bold">int</span> permits) {
    sync = <span style="color:#fff;font-weight:bold">new</span> NonfairSync(permits);
}

<span style="color:#fff;font-weight:bold">public</span> Semaphore(<span style="color:#fff;font-weight:bold">int</span> permits, <span style="color:#fff;font-weight:bold">boolean</span> fair) {
    sync = fair ? <span style="color:#fff;font-weight:bold">new</span> FairSync(permits) : <span style="color:#fff;font-weight:bold">new</span> NonfairSync(permits);
}
</code></pre></div><p>这里和 ReentrantLock 类似，用了公平策略和非公平策略。</p>
<p>看 acquire 方法：</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#fff;font-weight:bold">public</span> <span style="color:#fff;font-weight:bold">void</span> acquire() <span style="color:#fff;font-weight:bold">throws</span> InterruptedException {
    sync.<span style="color:#007f7f">acquireSharedInterruptibly</span>(1);
}
<span style="color:#fff;font-weight:bold">public</span> <span style="color:#fff;font-weight:bold">void</span> acquireUninterruptibly() {
    sync.<span style="color:#007f7f">acquireShared</span>(1);
}
<span style="color:#fff;font-weight:bold">public</span> <span style="color:#fff;font-weight:bold">void</span> acquire(<span style="color:#fff;font-weight:bold">int</span> permits) <span style="color:#fff;font-weight:bold">throws</span> InterruptedException {
    <span style="color:#fff;font-weight:bold">if</span> (permits &lt; 0) <span style="color:#fff;font-weight:bold">throw</span> <span style="color:#fff;font-weight:bold">new</span> IllegalArgumentException();
    sync.<span style="color:#007f7f">acquireSharedInterruptibly</span>(permits);
}
<span style="color:#fff;font-weight:bold">public</span> <span style="color:#fff;font-weight:bold">void</span> acquireUninterruptibly(<span style="color:#fff;font-weight:bold">int</span> permits) {
    <span style="color:#fff;font-weight:bold">if</span> (permits &lt; 0) <span style="color:#fff;font-weight:bold">throw</span> <span style="color:#fff;font-weight:bold">new</span> IllegalArgumentException();
    sync.<span style="color:#007f7f">acquireShared</span>(permits);
}
</code></pre></div><p>这几个方法也是老套路了，大家基本都懂了吧，这边多了两个可以传参的 acquire 方法，不过大家也都懂的吧，如果我们需要一次获取超过一个的资源，会用得着这个的。</p>
<p>我们接下来看不抛出 InterruptedException 异常的 acquireUninterruptibly() 方法吧：</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#fff;font-weight:bold">public</span> <span style="color:#fff;font-weight:bold">void</span> acquireUninterruptibly() {
    sync.<span style="color:#007f7f">acquireShared</span>(1);
}
<span style="color:#fff;font-weight:bold">public</span> <span style="color:#fff;font-weight:bold">final</span> <span style="color:#fff;font-weight:bold">void</span> acquireShared(<span style="color:#fff;font-weight:bold">int</span> arg) {
    <span style="color:#fff;font-weight:bold">if</span> (tryAcquireShared(arg) &lt; 0)
        doAcquireShared(arg);
}
</code></pre></div><p>前面说了，Semaphore 分公平策略和非公平策略，我们对比一下两个 tryAcquireShared 方法：</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#007f7f">// 公平策略：
</span><span style="color:#007f7f"></span><span style="color:#fff;font-weight:bold">protected</span> <span style="color:#fff;font-weight:bold">int</span> tryAcquireShared(<span style="color:#fff;font-weight:bold">int</span> acquires) {
    <span style="color:#fff;font-weight:bold">for</span> (;;) {
        <span style="color:#007f7f">// 区别就在于是不是会先判断是否有线程在排队，然后才进行 CAS 减操作
</span><span style="color:#007f7f"></span>        <span style="color:#fff;font-weight:bold">if</span> (hasQueuedPredecessors())
            <span style="color:#fff;font-weight:bold">return</span> -1;
        <span style="color:#fff;font-weight:bold">int</span> available = getState();
        <span style="color:#fff;font-weight:bold">int</span> remaining = available - acquires;
        <span style="color:#fff;font-weight:bold">if</span> (remaining &lt; 0 ||
            compareAndSetState(available, remaining))
            <span style="color:#fff;font-weight:bold">return</span> remaining;
    }
}
<span style="color:#007f7f">// 非公平策略：
</span><span style="color:#007f7f"></span><span style="color:#fff;font-weight:bold">protected</span> <span style="color:#fff;font-weight:bold">int</span> tryAcquireShared(<span style="color:#fff;font-weight:bold">int</span> acquires) {
    <span style="color:#fff;font-weight:bold">return</span> nonfairTryAcquireShared(acquires);
}
<span style="color:#fff;font-weight:bold">final</span> <span style="color:#fff;font-weight:bold">int</span> nonfairTryAcquireShared(<span style="color:#fff;font-weight:bold">int</span> acquires) {
    <span style="color:#fff;font-weight:bold">for</span> (;;) {
        <span style="color:#fff;font-weight:bold">int</span> available = getState();
        <span style="color:#fff;font-weight:bold">int</span> remaining = available - acquires;
        <span style="color:#fff;font-weight:bold">if</span> (remaining &lt; 0 ||
            compareAndSetState(available, remaining))
            <span style="color:#fff;font-weight:bold">return</span> remaining;
    }
}
</code></pre></div><p>也是老套路了，所以从源码分析角度的话，我们其实不太需要关心是不是公平策略还是非公平策略，它们的区别往往就那么一两行。</p>
<p>我们再回到 acquireShared 方法，</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#fff;font-weight:bold">public</span> <span style="color:#fff;font-weight:bold">final</span> <span style="color:#fff;font-weight:bold">void</span> acquireShared(<span style="color:#fff;font-weight:bold">int</span> arg) {
    <span style="color:#fff;font-weight:bold">if</span> (tryAcquireShared(arg) &lt; 0)
        doAcquireShared(arg);
}
</code></pre></div><p>由于 tryAcquireShared(arg) 返回小于 0 的时候，说明 state 已经小于 0 了（没资源了），此时 acquire 不能立马拿到资源，需要进入到阻塞队列等待，虽然贴了很多代码，不在乎多这点了：</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#fff;font-weight:bold">private</span> <span style="color:#fff;font-weight:bold">void</span> doAcquireShared(<span style="color:#fff;font-weight:bold">int</span> arg) {
    <span style="color:#fff;font-weight:bold">final</span> Node node = addWaiter(Node.<span style="color:#007f7f">SHARED</span>);
    <span style="color:#fff;font-weight:bold">boolean</span> failed = <span style="color:#fff;font-weight:bold">true</span>;
    <span style="color:#fff;font-weight:bold">try</span> {
        <span style="color:#fff;font-weight:bold">boolean</span> interrupted = <span style="color:#fff;font-weight:bold">false</span>;
        <span style="color:#fff;font-weight:bold">for</span> (;;) {
            <span style="color:#fff;font-weight:bold">final</span> Node p = node.<span style="color:#007f7f">predecessor</span>();
            <span style="color:#fff;font-weight:bold">if</span> (p == head) {
                <span style="color:#fff;font-weight:bold">int</span> r = tryAcquireShared(arg);
                <span style="color:#fff;font-weight:bold">if</span> (r &gt;= 0) {
                    setHeadAndPropagate(node, r);
                    p.<span style="color:#007f7f">next</span> = <span style="color:#fff;font-weight:bold">null</span>; <span style="color:#007f7f">// help GC
</span><span style="color:#007f7f"></span>                    <span style="color:#fff;font-weight:bold">if</span> (interrupted)
                        selfInterrupt();
                    failed = <span style="color:#fff;font-weight:bold">false</span>;
                    <span style="color:#fff;font-weight:bold">return</span>;
                }
            }
            <span style="color:#fff;font-weight:bold">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;
                parkAndCheckInterrupt())
                interrupted = <span style="color:#fff;font-weight:bold">true</span>;
        }
    } <span style="color:#fff;font-weight:bold">finally</span> {
        <span style="color:#fff;font-weight:bold">if</span> (failed)
            cancelAcquire(node);
    }
}
</code></pre></div><p>这个方法我就不介绍了，线程挂起后等待有资源被 release 出来。接下来，我们就要看 release 的方法了：</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#007f7f">// 任务介绍，释放一个资源
</span><span style="color:#007f7f"></span><span style="color:#fff;font-weight:bold">public</span> <span style="color:#fff;font-weight:bold">void</span> release() {
    sync.<span style="color:#007f7f">releaseShared</span>(1);
}
<span style="color:#fff;font-weight:bold">public</span> <span style="color:#fff;font-weight:bold">final</span> <span style="color:#fff;font-weight:bold">boolean</span> releaseShared(<span style="color:#fff;font-weight:bold">int</span> arg) {
    <span style="color:#fff;font-weight:bold">if</span> (tryReleaseShared(arg)) {
        doReleaseShared();
        <span style="color:#fff;font-weight:bold">return</span> <span style="color:#fff;font-weight:bold">true</span>;
    }
    <span style="color:#fff;font-weight:bold">return</span> <span style="color:#fff;font-weight:bold">false</span>;
}

<span style="color:#fff;font-weight:bold">protected</span> <span style="color:#fff;font-weight:bold">final</span> <span style="color:#fff;font-weight:bold">boolean</span> tryReleaseShared(<span style="color:#fff;font-weight:bold">int</span> releases) {
    <span style="color:#fff;font-weight:bold">for</span> (;;) {
        <span style="color:#fff;font-weight:bold">int</span> current = getState();
        <span style="color:#fff;font-weight:bold">int</span> next = current + releases;
        <span style="color:#007f7f">// 溢出，当然，我们一般也不会用这么大的数
</span><span style="color:#007f7f"></span>        <span style="color:#fff;font-weight:bold">if</span> (next &lt; current) <span style="color:#007f7f">// overflow
</span><span style="color:#007f7f"></span>            <span style="color:#fff;font-weight:bold">throw</span> <span style="color:#fff;font-weight:bold">new</span> Error(<span style="color:#0ff;font-weight:bold">&#34;Maximum permit count exceeded&#34;</span>);
        <span style="color:#fff;font-weight:bold">if</span> (compareAndSetState(current, next))
            <span style="color:#fff;font-weight:bold">return</span> <span style="color:#fff;font-weight:bold">true</span>;
    }
}
</code></pre></div><p>tryReleaseShared 方法总是会返回 true，然后是 doReleaseShared，这个也是我们熟悉的方法了，我就贴下代码，不分析了，这个方法用于唤醒所有的等待线程：</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#fff;font-weight:bold">private</span> <span style="color:#fff;font-weight:bold">void</span> doReleaseShared() {
    <span style="color:#fff;font-weight:bold">for</span> (;;) {
        Node h = head;
        <span style="color:#fff;font-weight:bold">if</span> (h != <span style="color:#fff;font-weight:bold">null</span> &amp;&amp; h != tail) {
            <span style="color:#fff;font-weight:bold">int</span> ws = h.<span style="color:#007f7f">waitStatus</span>;
            <span style="color:#fff;font-weight:bold">if</span> (ws == Node.<span style="color:#007f7f">SIGNAL</span>) {
                <span style="color:#fff;font-weight:bold">if</span> (!compareAndSetWaitStatus(h, Node.<span style="color:#007f7f">SIGNAL</span>, 0))
                    <span style="color:#fff;font-weight:bold">continue</span>;            <span style="color:#007f7f">// loop to recheck cases
</span><span style="color:#007f7f"></span>                unparkSuccessor(h);
            }
            <span style="color:#fff;font-weight:bold">else</span> <span style="color:#fff;font-weight:bold">if</span> (ws == 0 &amp;&amp;
                     !compareAndSetWaitStatus(h, 0, Node.<span style="color:#007f7f">PROPAGATE</span>))
                <span style="color:#fff;font-weight:bold">continue</span>;                <span style="color:#007f7f">// loop on failed CAS
</span><span style="color:#007f7f"></span>        }
        <span style="color:#fff;font-weight:bold">if</span> (h == head)                   <span style="color:#007f7f">// loop if head changed
</span><span style="color:#007f7f"></span>            <span style="color:#fff;font-weight:bold">break</span>;
    }
}
</code></pre></div><p>Semphore 的源码确实很简单，基本上都是分析过的老代码的组合使用了。</p>
<h2 id="总结">总结</h2>
<p>写到这里，终于把 AbstractQueuedSynchronizer 基本上说完了，对于 Java 并发，Doug Lea 真的是神一样的存在。日后我们还会接触到很多 Doug Lea 的代码，希望我们大家都可以朝着大神的方向不断打磨自己的技术，少一些高大上的架构，多一些实实在在的优秀代码吧。</p>
<p>（全文完）</p>
<p><strong>著作权归原作者所有，<a href="https://javadoop.com/post/AbstractQueuedSynchronizer-3">原文链接</a>。</strong></p>

  </article>
</section>


    </div>

    <footer class="footer">
  <div class="footer-taxonomy">
    <div style="margin-bottom: 10px;">
      <a href="https://wiki.bmpi.dev/" rel="nofollow">Wiki</a>
      ⚔️
      <a href="https://talk.bmpi.dev/" rel="nofollow">Talk</a>
      ⚔️
      <a href="https://www.notion.so/mdw/e0ed086e701a4d0aaa4839d2c7aa62ea" rel="nofollow">Portfolio</a>
      ⚔️
      <a href="https://money.i365.tech/">Money</a>
    </div>
    <div>
      <a href= /affiliate >Affiliate</a>
      ⚡️
      <a href= /tool >Tool</a>
      ⚡️
      <a href= /link >Link</a>
    </div>
  </div>
  <div class="footer-taxonomy">
    <a href= /tags style="color: #B36D61;">Tags</a>
    👈
    <a href= /categories style="color: #FF8C31;">Categories</a>
    👉
    <a href= /series style="color: #519A73;">Series</a>
  </div>
  <section class="container">
    
     © 2019 - 2020
    
    
  </section>
</footer>

  </main>

  
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-154678195-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag() { dataLayer.push(arguments); }
    gtag('js', new Date());

    gtag('config', 'UA-154678195-1');
  </script>
  

  
  <script>(function(w,d, s, id) {w.webpushr=w.webpushr||function(){(w.webpushr.q=w.webpushr.q||[]).push(arguments)};var js, fjs = d.getElementsByTagName(s)[0];js = d.createElement(s); js.id = id;js.src = "https://cdn.webpushr.com/app.min.js";fjs.parentNode.appendChild(js);}(window,document, 'script', 'webpushr-jssdk'));webpushr('init','BHuwaXciWicBjh6HQS2tfudv6IYQD11K9u1NUj7nuaEV9NoDT7ns9JjgqyYTflUv-m3TlD7ELY84AHMfgmPXNgU');</script>
  

</body>

</html>
